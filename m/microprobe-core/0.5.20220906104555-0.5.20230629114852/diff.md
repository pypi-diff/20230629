# Comparing `tmp/microprobe_core-0.5.20220906104555-py2.py3-none-any.whl.zip` & `tmp/microprobe_core-0.5.20230629114852-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,119 +1,119 @@
-Zip file size: 344611 bytes, number of entries: 117
--rw-r--r--  2.0 unx     9236 b- defN 22-Jul-27 13:33 microprobe/__init__.py
--rw-r--r--  2.0 unx     6504 b- defN 22-Jul-27 13:33 microprobe/exceptions.py
--rw-rw-r--  2.0 unx      772 b- defN 22-Sep-06 14:45 microprobe/microprobe.cfg
--rw-r--r--  2.0 unx    10213 b- defN 22-Jul-27 13:33 microprobe/property.py
--rw-r--r--  2.0 unx    25912 b- defN 22-Jul-27 13:33 microprobe/code/__init__.py
--rw-r--r--  2.0 unx    14640 b- defN 22-Jul-27 13:33 microprobe/code/address.py
--rw-r--r--  2.0 unx    11088 b- defN 22-Jul-27 13:33 microprobe/code/bbl.py
--rw-r--r--  2.0 unx    14023 b- defN 22-Jul-27 13:33 microprobe/code/benchmark.py
--rw-r--r--  2.0 unx     3379 b- defN 22-Jul-27 13:33 microprobe/code/cfg.py
--rw-r--r--  2.0 unx    17316 b- defN 22-Jul-27 13:33 microprobe/code/context.py
--rw-r--r--  2.0 unx    74582 b- defN 22-Jul-27 13:33 microprobe/code/ins.py
--rw-r--r--  2.0 unx    11674 b- defN 22-Jul-27 13:33 microprobe/code/var.py
--rw-r--r--  2.0 unx     5909 b- defN 22-Jul-27 13:33 microprobe/code/wrapper.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:45 microprobe/definitions/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/policies/__init__.py
--rw-r--r--  2.0 unx     2919 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/policies/debug.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/templates/__init__.py
--rw-r--r--  2.0 unx    13660 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/templates/c2mpt.c
--rw-r--r--  2.0 unx     5103 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/templates/c2mpt.h
--rw-r--r--  2.0 unx     3595 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/templates/c2mpt_template.c
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/__init__.py
--rw-r--r--  2.0 unx     3598 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_bin2asm.py
--rw-r--r--  2.0 unx     7592 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_bin2objdump.py
--rw-r--r--  2.0 unx    18592 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_c2mpt.py
--rw-r--r--  2.0 unx    12632 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_epi.py
--rw-r--r--  2.0 unx    37529 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_mpt2bin.py
--rw-r--r--  2.0 unx    42126 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_mpt2elf.py
--rw-r--r--  2.0 unx    11772 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_mpt2test.py
--rw-r--r--  2.0 unx     9698 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_objdump2mpt.py
--rw-r--r--  2.0 unx    21242 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_seq.py
--rw-r--r--  2.0 unx    26322 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_seqtune.py
--rw-r--r--  2.0 unx     3321 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/tools/mp_target.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/__init__.py
--rw-r--r--  2.0 unx     3568 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/asm.py
--rw-r--r--  2.0 unx    10928 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/asmld.py
--rw-r--r--  2.0 unx     5723 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/bin.py
--rw-r--r--  2.0 unx    17830 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/c.py
--rw-r--r--  2.0 unx    19973 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/cpapi.py
--rw-r--r--  2.0 unx     4480 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/debug.py
--rw-r--r--  2.0 unx     7605 b- defN 22-Sep-06 14:45 microprobe/definitions/generic/wrappers/trace.py
--rw-r--r--  2.0 unx      671 b- defN 22-Jul-27 13:33 microprobe/driver/__init__.py
--rw-r--r--  2.0 unx    10949 b- defN 22-Jul-27 13:33 microprobe/driver/genetic.py
--rw-r--r--  2.0 unx      677 b- defN 22-Jul-27 13:33 microprobe/driver/guided.py
--rw-r--r--  2.0 unx     1642 b- defN 22-Jul-27 13:33 microprobe/model/__init__.py
--rw-r--r--  2.0 unx    13892 b- defN 22-Jul-27 13:33 microprobe/model/memory.py
--rw-r--r--  2.0 unx     2180 b- defN 22-Jul-27 13:33 microprobe/passes/__init__.py
--rw-r--r--  2.0 unx     7684 b- defN 22-Jul-27 13:33 microprobe/passes/address/__init__.py
--rw-r--r--  2.0 unx    58027 b- defN 22-Sep-06 14:43 microprobe/passes/branch/__init__.py
--rw-r--r--  2.0 unx     2527 b- defN 22-Jul-27 13:33 microprobe/passes/dat/__init__.py
--rw-r--r--  2.0 unx     3028 b- defN 22-Jul-27 13:33 microprobe/passes/decimal/__init__.py
--rw-r--r--  2.0 unx     6533 b- defN 22-Jul-27 13:33 microprobe/passes/float/__init__.py
--rw-r--r--  2.0 unx     3129 b- defN 22-Jul-27 13:33 microprobe/passes/ilp/__init__.py
--rw-r--r--  2.0 unx    17355 b- defN 22-Jul-27 13:33 microprobe/passes/initialization/__init__.py
--rw-r--r--  2.0 unx    45784 b- defN 22-Jul-27 13:33 microprobe/passes/instruction/__init__.py
--rw-r--r--  2.0 unx   106225 b- defN 22-Sep-06 14:43 microprobe/passes/memory/__init__.py
--rw-r--r--  2.0 unx    39864 b- defN 22-Jul-27 13:33 microprobe/passes/register/__init__.py
--rw-r--r--  2.0 unx     7658 b- defN 22-Jul-27 13:33 microprobe/passes/structure/__init__.py
--rw-r--r--  2.0 unx    28125 b- defN 22-Jul-27 13:33 microprobe/passes/switch/__init__.py
--rw-r--r--  2.0 unx    11544 b- defN 22-Jul-27 13:33 microprobe/passes/symbol/__init__.py
--rw-r--r--  2.0 unx     7484 b- defN 22-Jul-27 13:33 microprobe/passes/variable/__init__.py
--rw-r--r--  2.0 unx      710 b- defN 22-Jul-27 13:33 microprobe/schemas/__init__.py
--rw-rw-r--  2.0 unx     1310 b- defN 22-Jul-27 13:33 microprobe/schemas/property.yaml
--rw-r--r--  2.0 unx    19638 b- defN 22-Jul-27 13:33 microprobe/target/__init__.py
--rw-r--r--  2.0 unx    12398 b- defN 22-Jul-27 13:33 microprobe/target/env/__init__.py
--rw-r--r--  2.0 unx    26085 b- defN 22-Sep-06 14:43 microprobe/target/isa/__init__.py
--rw-r--r--  2.0 unx     4486 b- defN 22-Jul-27 13:33 microprobe/target/isa/comparator.py
--rw-r--r--  2.0 unx     6482 b- defN 22-Jul-27 13:33 microprobe/target/isa/dat.py
--rw-r--r--  2.0 unx     3506 b- defN 22-Jul-27 13:33 microprobe/target/isa/generator.py
--rw-r--r--  2.0 unx    66656 b- defN 22-Jul-27 13:33 microprobe/target/isa/instruction.py
--rw-r--r--  2.0 unx     5783 b- defN 22-Jul-27 13:33 microprobe/target/isa/instruction_field.py
--rw-r--r--  2.0 unx    12051 b- defN 22-Jul-27 13:33 microprobe/target/isa/instruction_format.py
--rw-r--r--  2.0 unx    42994 b- defN 22-Jul-27 13:33 microprobe/target/isa/operand.py
--rw-r--r--  2.0 unx     9736 b- defN 22-Jul-27 13:33 microprobe/target/isa/register.py
--rw-r--r--  2.0 unx     8284 b- defN 22-Jul-27 13:33 microprobe/target/isa/register_type.py
--rw-rw-r--  2.0 unx     1075 b- defN 22-Jul-27 13:33 microprobe/target/isa/default/isa.yaml
--rw-r--r--  2.0 unx      710 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/__init__.py
--rw-rw-r--  2.0 unx     1755 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/instruction.yaml
--rw-rw-r--  2.0 unx      956 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/instruction_field.yaml
--rw-rw-r--  2.0 unx      907 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/instruction_format.yaml
--rw-rw-r--  2.0 unx     2884 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/isa.yaml
--rw-rw-r--  2.0 unx     3948 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/operand.yaml
--rw-rw-r--  2.0 unx     1119 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/register.yaml
--rw-rw-r--  2.0 unx      941 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/register_type.yaml
--rw-r--r--  2.0 unx    11307 b- defN 22-Jul-27 13:33 microprobe/target/uarch/__init__.py
--rw-r--r--  2.0 unx    14318 b- defN 22-Jul-27 13:33 microprobe/target/uarch/cache.py
--rw-r--r--  2.0 unx    13221 b- defN 22-Jul-27 13:33 microprobe/target/uarch/element.py
--rw-r--r--  2.0 unx     4498 b- defN 22-Jul-27 13:33 microprobe/target/uarch/element_type.py
--rw-rw-r--  2.0 unx      951 b- defN 22-Jul-27 13:33 microprobe/target/uarch/default/microarchitecture.yaml
--rw-r--r--  2.0 unx      710 b- defN 22-Jul-27 13:33 microprobe/target/uarch/schemas/__init__.py
--rw-rw-r--  2.0 unx     1094 b- defN 22-Jul-27 13:33 microprobe/target/uarch/schemas/element.yaml
--rw-rw-r--  2.0 unx      761 b- defN 22-Jul-27 13:33 microprobe/target/uarch/schemas/element_type.yaml
--rw-rw-r--  2.0 unx     1649 b- defN 22-Jul-27 13:33 microprobe/target/uarch/schemas/microarchitecture.yaml
--rw-r--r--  2.0 unx      670 b- defN 22-Jul-27 13:33 microprobe/utils/__init__.py
--rw-r--r--  2.0 unx    46408 b- defN 22-Sep-06 14:43 microprobe/utils/asm.py
--rw-r--r--  2.0 unx    33575 b- defN 22-Sep-06 14:43 microprobe/utils/bin.py
--rw-r--r--  2.0 unx     6526 b- defN 22-Sep-06 14:43 microprobe/utils/cache.py
--rw-r--r--  2.0 unx    56510 b- defN 22-Sep-06 14:43 microprobe/utils/cmdline.py
--rw-r--r--  2.0 unx    18127 b- defN 22-Jul-27 13:33 microprobe/utils/config.py
--rw-r--r--  2.0 unx    10924 b- defN 22-Jul-27 13:33 microprobe/utils/distrib.py
--rw-r--r--  2.0 unx     3092 b- defN 22-Jul-27 13:33 microprobe/utils/ieee.py
--rw-r--r--  2.0 unx     8536 b- defN 22-Jul-27 13:33 microprobe/utils/imp.py
--rw-r--r--  2.0 unx     2545 b- defN 22-Jul-27 13:33 microprobe/utils/info.py
--rw-r--r--  2.0 unx     3055 b- defN 22-Jul-27 13:33 microprobe/utils/logger.py
--rw-r--r--  2.0 unx    14194 b- defN 22-Jul-27 13:33 microprobe/utils/misc.py
--rw-r--r--  2.0 unx    72494 b- defN 22-Sep-06 14:43 microprobe/utils/mpt.py
--rw-r--r--  2.0 unx    11342 b- defN 22-Jul-27 13:33 microprobe/utils/objdump.py
--rw-r--r--  2.0 unx     2718 b- defN 22-Jul-27 13:33 microprobe/utils/policy.py
--rw-r--r--  2.0 unx     1169 b- defN 22-Jul-27 13:33 microprobe/utils/profile.py
--rw-r--r--  2.0 unx     2869 b- defN 22-Jul-27 13:33 microprobe/utils/run.py
--rw-r--r--  2.0 unx     5319 b- defN 22-Jul-27 13:33 microprobe/utils/yaml.py
--rw-rw-r--  2.0 unx    11356 b- defN 22-Sep-06 14:46 microprobe_core-0.5.20220906104555.dist-info/LICENSE
--rw-r--r--  2.0 unx     1820 b- defN 22-Sep-06 14:46 microprobe_core-0.5.20220906104555.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 22-Sep-06 14:46 microprobe_core-0.5.20220906104555.dist-info/WHEEL
--rw-r--r--  2.0 unx      740 b- defN 22-Sep-06 14:46 microprobe_core-0.5.20220906104555.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       11 b- defN 22-Sep-06 14:46 microprobe_core-0.5.20220906104555.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    11021 b- defN 22-Sep-06 14:46 microprobe_core-0.5.20220906104555.dist-info/RECORD
-117 files, 1478088 bytes uncompressed, 326911 bytes compressed:  77.9%
+Zip file size: 346241 bytes, number of entries: 117
+-rw-r--r--  2.0 unx     9236 b- defN 23-Jun-21 21:07 microprobe/__init__.py
+-rw-r--r--  2.0 unx     6504 b- defN 23-Jun-21 21:07 microprobe/exceptions.py
+-rw-r--r--  2.0 unx      772 b- defN 23-Jun-29 15:48 microprobe/microprobe.cfg
+-rw-r--r--  2.0 unx    10213 b- defN 23-Jun-21 21:07 microprobe/property.py
+-rw-r--r--  2.0 unx    25912 b- defN 23-Jun-21 21:07 microprobe/code/__init__.py
+-rw-r--r--  2.0 unx    14640 b- defN 23-Jun-21 21:07 microprobe/code/address.py
+-rw-r--r--  2.0 unx    11088 b- defN 23-Jun-21 21:07 microprobe/code/bbl.py
+-rw-r--r--  2.0 unx    14023 b- defN 23-Jun-21 21:07 microprobe/code/benchmark.py
+-rw-r--r--  2.0 unx     3379 b- defN 23-Jun-21 21:07 microprobe/code/cfg.py
+-rw-r--r--  2.0 unx    18207 b- defN 23-Jun-21 22:19 microprobe/code/context.py
+-rw-r--r--  2.0 unx    74582 b- defN 23-Jun-21 21:07 microprobe/code/ins.py
+-rw-r--r--  2.0 unx    11674 b- defN 23-Jun-21 21:07 microprobe/code/var.py
+-rw-r--r--  2.0 unx     5909 b- defN 23-Jun-21 21:07 microprobe/code/wrapper.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/policies/__init__.py
+-rw-r--r--  2.0 unx     2919 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/policies/debug.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/templates/__init__.py
+-rw-r--r--  2.0 unx    13660 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/templates/c2mpt.c
+-rw-r--r--  2.0 unx     5103 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/templates/c2mpt.h
+-rw-r--r--  2.0 unx     3595 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/templates/c2mpt_template.c
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/__init__.py
+-rw-r--r--  2.0 unx     3598 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_bin2asm.py
+-rw-r--r--  2.0 unx     7592 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_bin2objdump.py
+-rw-r--r--  2.0 unx    18592 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_c2mpt.py
+-rw-r--r--  2.0 unx    12632 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_epi.py
+-rw-r--r--  2.0 unx    37529 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_mpt2bin.py
+-rw-r--r--  2.0 unx    49314 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_mpt2elf.py
+-rw-r--r--  2.0 unx    11772 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_mpt2test.py
+-rw-r--r--  2.0 unx     9698 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_objdump2mpt.py
+-rw-r--r--  2.0 unx    21242 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_seq.py
+-rw-r--r--  2.0 unx    26322 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_seqtune.py
+-rw-r--r--  2.0 unx     3321 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/tools/mp_target.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/__init__.py
+-rw-r--r--  2.0 unx     3568 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/asm.py
+-rw-r--r--  2.0 unx    10938 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/asmld.py
+-rw-r--r--  2.0 unx     5723 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/bin.py
+-rw-r--r--  2.0 unx    17830 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/c.py
+-rw-r--r--  2.0 unx    19973 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/cpapi.py
+-rw-r--r--  2.0 unx     4480 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/debug.py
+-rw-r--r--  2.0 unx     7605 b- defN 23-Jun-29 15:48 microprobe/definitions/generic/wrappers/trace.py
+-rw-r--r--  2.0 unx      671 b- defN 23-Jun-21 21:07 microprobe/driver/__init__.py
+-rw-r--r--  2.0 unx    10949 b- defN 23-Jun-21 21:07 microprobe/driver/genetic.py
+-rw-r--r--  2.0 unx      677 b- defN 23-Jun-21 21:07 microprobe/driver/guided.py
+-rw-r--r--  2.0 unx     1642 b- defN 23-Jun-21 21:07 microprobe/model/__init__.py
+-rw-r--r--  2.0 unx    13892 b- defN 23-Jun-21 21:07 microprobe/model/memory.py
+-rw-r--r--  2.0 unx     2180 b- defN 23-Jun-21 21:07 microprobe/passes/__init__.py
+-rw-r--r--  2.0 unx     7684 b- defN 23-Jun-21 21:07 microprobe/passes/address/__init__.py
+-rw-r--r--  2.0 unx    58027 b- defN 23-Jun-21 21:07 microprobe/passes/branch/__init__.py
+-rw-r--r--  2.0 unx     2527 b- defN 23-Jun-21 21:07 microprobe/passes/dat/__init__.py
+-rw-r--r--  2.0 unx     3028 b- defN 23-Jun-21 21:07 microprobe/passes/decimal/__init__.py
+-rw-r--r--  2.0 unx     6533 b- defN 23-Jun-21 21:07 microprobe/passes/float/__init__.py
+-rw-r--r--  2.0 unx     3129 b- defN 23-Jun-21 21:07 microprobe/passes/ilp/__init__.py
+-rw-r--r--  2.0 unx    17532 b- defN 23-Jun-21 22:53 microprobe/passes/initialization/__init__.py
+-rw-r--r--  2.0 unx    45784 b- defN 23-Jun-21 21:07 microprobe/passes/instruction/__init__.py
+-rw-r--r--  2.0 unx   106225 b- defN 23-Jun-21 21:07 microprobe/passes/memory/__init__.py
+-rw-r--r--  2.0 unx    39864 b- defN 23-Jun-21 21:07 microprobe/passes/register/__init__.py
+-rw-r--r--  2.0 unx     7658 b- defN 23-Jun-21 21:07 microprobe/passes/structure/__init__.py
+-rw-r--r--  2.0 unx    28125 b- defN 23-Jun-21 21:07 microprobe/passes/switch/__init__.py
+-rw-r--r--  2.0 unx    11544 b- defN 23-Jun-21 21:07 microprobe/passes/symbol/__init__.py
+-rw-r--r--  2.0 unx     7484 b- defN 23-Jun-21 21:07 microprobe/passes/variable/__init__.py
+-rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/schemas/__init__.py
+-rw-rw-r--  2.0 unx     1310 b- defN 23-Jun-21 21:07 microprobe/schemas/property.yaml
+-rw-r--r--  2.0 unx    19638 b- defN 23-Jun-21 21:07 microprobe/target/__init__.py
+-rw-r--r--  2.0 unx    13404 b- defN 23-Jun-21 22:53 microprobe/target/env/__init__.py
+-rw-r--r--  2.0 unx    26085 b- defN 23-Jun-21 21:07 microprobe/target/isa/__init__.py
+-rw-r--r--  2.0 unx     4486 b- defN 23-Jun-21 21:07 microprobe/target/isa/comparator.py
+-rw-r--r--  2.0 unx     6482 b- defN 23-Jun-21 21:07 microprobe/target/isa/dat.py
+-rw-r--r--  2.0 unx     3506 b- defN 23-Jun-21 21:07 microprobe/target/isa/generator.py
+-rw-r--r--  2.0 unx    66656 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction.py
+-rw-r--r--  2.0 unx     5783 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction_field.py
+-rw-r--r--  2.0 unx    12051 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction_format.py
+-rw-r--r--  2.0 unx    42994 b- defN 23-Jun-21 21:07 microprobe/target/isa/operand.py
+-rw-r--r--  2.0 unx     9736 b- defN 23-Jun-21 21:07 microprobe/target/isa/register.py
+-rw-r--r--  2.0 unx     8284 b- defN 23-Jun-21 21:07 microprobe/target/isa/register_type.py
+-rw-rw-r--  2.0 unx     1075 b- defN 23-Jun-21 21:07 microprobe/target/isa/default/isa.yaml
+-rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/__init__.py
+-rw-rw-r--  2.0 unx     1755 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/instruction.yaml
+-rw-rw-r--  2.0 unx      956 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/instruction_field.yaml
+-rw-rw-r--  2.0 unx      907 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/instruction_format.yaml
+-rw-rw-r--  2.0 unx     2884 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/isa.yaml
+-rw-rw-r--  2.0 unx     3948 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/operand.yaml
+-rw-rw-r--  2.0 unx     1119 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/register.yaml
+-rw-rw-r--  2.0 unx      941 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/register_type.yaml
+-rw-r--r--  2.0 unx    11307 b- defN 23-Jun-21 21:07 microprobe/target/uarch/__init__.py
+-rw-r--r--  2.0 unx    14318 b- defN 23-Jun-21 21:07 microprobe/target/uarch/cache.py
+-rw-r--r--  2.0 unx    13221 b- defN 23-Jun-21 21:07 microprobe/target/uarch/element.py
+-rw-r--r--  2.0 unx     4498 b- defN 23-Jun-21 21:07 microprobe/target/uarch/element_type.py
+-rw-rw-r--  2.0 unx      951 b- defN 23-Jun-21 21:07 microprobe/target/uarch/default/microarchitecture.yaml
+-rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/target/uarch/schemas/__init__.py
+-rw-rw-r--  2.0 unx     1094 b- defN 23-Jun-21 21:07 microprobe/target/uarch/schemas/element.yaml
+-rw-rw-r--  2.0 unx      761 b- defN 23-Jun-21 21:07 microprobe/target/uarch/schemas/element_type.yaml
+-rw-rw-r--  2.0 unx     1649 b- defN 23-Jun-21 21:07 microprobe/target/uarch/schemas/microarchitecture.yaml
+-rw-r--r--  2.0 unx      670 b- defN 23-Jun-21 21:07 microprobe/utils/__init__.py
+-rw-r--r--  2.0 unx    46408 b- defN 23-Jun-21 21:07 microprobe/utils/asm.py
+-rw-r--r--  2.0 unx    33575 b- defN 23-Jun-21 21:07 microprobe/utils/bin.py
+-rw-r--r--  2.0 unx     6526 b- defN 23-Jun-21 21:07 microprobe/utils/cache.py
+-rw-r--r--  2.0 unx    56510 b- defN 23-Jun-21 21:07 microprobe/utils/cmdline.py
+-rw-r--r--  2.0 unx    18127 b- defN 23-Jun-21 21:07 microprobe/utils/config.py
+-rw-r--r--  2.0 unx    10924 b- defN 23-Jun-21 21:07 microprobe/utils/distrib.py
+-rw-r--r--  2.0 unx     3092 b- defN 23-Jun-21 21:07 microprobe/utils/ieee.py
+-rw-r--r--  2.0 unx     8536 b- defN 23-Jun-21 21:07 microprobe/utils/imp.py
+-rw-r--r--  2.0 unx     2545 b- defN 23-Jun-21 21:07 microprobe/utils/info.py
+-rw-r--r--  2.0 unx     3055 b- defN 23-Jun-21 21:07 microprobe/utils/logger.py
+-rw-r--r--  2.0 unx    14194 b- defN 23-Jun-21 21:07 microprobe/utils/misc.py
+-rw-r--r--  2.0 unx    72494 b- defN 23-Jun-21 21:07 microprobe/utils/mpt.py
+-rw-r--r--  2.0 unx    11342 b- defN 23-Jun-21 21:07 microprobe/utils/objdump.py
+-rw-r--r--  2.0 unx     2718 b- defN 23-Jun-21 21:07 microprobe/utils/policy.py
+-rw-r--r--  2.0 unx     1169 b- defN 23-Jun-21 21:07 microprobe/utils/profile.py
+-rw-r--r--  2.0 unx     2869 b- defN 23-Jun-21 21:07 microprobe/utils/run.py
+-rw-r--r--  2.0 unx     5319 b- defN 23-Jun-21 21:07 microprobe/utils/yaml.py
+-rw-rw-r--  2.0 unx    11356 b- defN 23-Jun-29 15:48 microprobe_core-0.5.20230629114852.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1820 b- defN 23-Jun-29 15:48 microprobe_core-0.5.20230629114852.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jun-29 15:48 microprobe_core-0.5.20230629114852.dist-info/WHEEL
+-rw-r--r--  2.0 unx      740 b- defN 23-Jun-29 15:48 microprobe_core-0.5.20230629114852.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       11 b- defN 23-Jun-29 15:48 microprobe_core-0.5.20230629114852.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    11021 b- defN 23-Jun-29 15:48 microprobe_core-0.5.20230629114852.dist-info/RECORD
+117 files, 1487360 bytes uncompressed, 328541 bytes compressed:  77.9%
```

## zipnote {}

```diff
@@ -327,26 +327,26 @@
 
 Filename: microprobe/utils/run.py
 Comment: 
 
 Filename: microprobe/utils/yaml.py
 Comment: 
 
-Filename: microprobe_core-0.5.20220906104555.dist-info/LICENSE
+Filename: microprobe_core-0.5.20230629114852.dist-info/LICENSE
 Comment: 
 
-Filename: microprobe_core-0.5.20220906104555.dist-info/METADATA
+Filename: microprobe_core-0.5.20230629114852.dist-info/METADATA
 Comment: 
 
-Filename: microprobe_core-0.5.20220906104555.dist-info/WHEEL
+Filename: microprobe_core-0.5.20230629114852.dist-info/WHEEL
 Comment: 
 
-Filename: microprobe_core-0.5.20220906104555.dist-info/entry_points.txt
+Filename: microprobe_core-0.5.20230629114852.dist-info/entry_points.txt
 Comment: 
 
-Filename: microprobe_core-0.5.20220906104555.dist-info/top_level.txt
+Filename: microprobe_core-0.5.20230629114852.dist-info/top_level.txt
 Comment: 
 
-Filename: microprobe_core-0.5.20220906104555.dist-info/RECORD
+Filename: microprobe_core-0.5.20230629114852.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## microprobe/microprobe.cfg

```diff
@@ -6,8 +6,8 @@
 architecture_paths = [ "MICROPROBE_INSTALL_DIR/definitions", "MICROPROBE_INSTALL_DIR/../../targets/" ]
 microarchitecture_paths = [ "MICROPROBE_INSTALL_DIR/definitions", "MICROPROBE_INSTALL_DIR/../../targets/" ]
 environment_paths = [ "MICROPROBE_INSTALL_DIR/definitions", "MICROPROBE_INSTALL_DIR/../../targets/" ]
 template_paths = [ "MICROPROBE_INSTALL_DIR/definitions", "MICROPROBE_INSTALL_DIR/../../targets/" ]
 wrapper_paths = [ "MICROPROBE_INSTALL_DIR/definitions", "MICROPROBE_INSTALL_DIR/../../targets/" ]
 parallel_threshold = 999999999999
 no_cache = False
-revision_core = master 61000a6 built on 20220906104555
+revision_core = master acf6268 built on 20230629114852
```

## microprobe/code/context.py

```diff
@@ -12,24 +12,32 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.context` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, print_function, annotations
+
+# Built-in modules
+from typing import TYPE_CHECKING, Tuple, Dict, List
 
 # Third party modules
 import six
 
 # Own modules
 from microprobe.code.address import Address, InstructionAddress
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import RejectingDict, smart_copy_dict
 
+# Type hints
+if TYPE_CHECKING:
+    from microprobe.target.isa.register import Register
+    from microprobe.code.address import MemoryValue
+    from microprobe.target.isa.dat import DynamicAddressTranslation
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["Context"]
 
 # Functions
 
@@ -40,32 +48,39 @@
     on each benchmark building block)
 
 
     """
 
     def __init__(
             self,
-            default_context=None,
-            code_segment=None,
-            data_segment=None,
-            symbolic=True,
-            absolute=False
+            default_context: Context | None = None,
+            code_segment: int | None = None,
+            data_segment: int | None = None,
+            symbolic: bool = True,
+            absolute: bool = False
     ):
         """
 
         :param default_context:  (Default value = None)
         :param code_segment:  (Default value = None)
         :param data_segment:  (Default value = None)
         :param symbolic:  (Default value = True)
 
         """
 
-        self._reserved_registers = RejectingDict()
-        self._register_values = [{}, {}]
-        self._memory_values = [{}, {}]
+        self._reserved_registers: Dict[str, Register] = RejectingDict()
+
+        self._register_values: Dict[
+            Register, int | float | Address | str | None
+        ] = {}
+        self._value_registers: Dict[
+            int | float | Address | str, List[Register]
+        ] = {}
+        self._memory_values: Dict[Address, MemoryValue] = {}
+        self._value_memorys: Dict[MemoryValue, List[MemoryValue]] = {}
 
         self._data_segment = data_segment
         self._code_segment = code_segment
         self._symbolic = symbolic
         self._fabsolute = absolute
 
         self._dat = None
@@ -78,58 +93,55 @@
 
         newcontext = Context()
 
         # pylint: disable=protected-access
         newcontext._reserved_registers = smart_copy_dict(
             self._reserved_registers
         )
-        newcontext._register_values[0] = smart_copy_dict(
-            self._register_values[0]
-        )
-        newcontext._register_values[1] = smart_copy_dict(
-            self._register_values[1]
-        )
-        newcontext._memory_values[0] = smart_copy_dict(self._memory_values[0])
-        newcontext._memory_values[1] = smart_copy_dict(
-            self._register_values[1]
-        )
+        newcontext._register_values = smart_copy_dict(self._register_values)
+        newcontext._value_registers = smart_copy_dict(self._value_registers)
+        newcontext._memory_values = smart_copy_dict(self._memory_values)
+        newcontext._value_memorys = smart_copy_dict(self._value_memorys)
 
         if self._dat is not None:
             newcontext.set_dat(self._dat.copy())
 
         newcontext.set_code_segment(self.code_segment)
         newcontext.set_data_segment(self.data_segment)
         newcontext.set_symbolic(self.symbolic)
         newcontext.set_absolute(self.force_absolute)
 
         return newcontext
 
-    def add_reserved_registers(self, rregs):
+    def add_reserved_registers(self, rregs: List[Register]):
         """Add the provided registers into the reserved register list.
 
         :param rregs: Registers to reserve
         :type rregs: :class:`~.list` of :class:`~.Register`
 
         """
 
         for reg in rregs:
             self._reserved_registers[reg.name] = reg
 
-    def remove_reserved_registers(self, rregs):
+    def remove_reserved_registers(self, rregs: List[Register]):
         """Remove the provided registers from the reserved register list.
 
         :param rregs: Registers to un-reserve
         :type rregs: :class:`~.list` of :class:`~.Register`
 
         """
 
         for reg in rregs:
             del self._reserved_registers[reg.name]
 
-    def set_register_value(self, register, value):
+    def set_register_value(
+            self,
+            register: Register, value: int | float | Address | str
+    ):
         """Set the provided register to the specified value.
 
         :param register: Register to set
         :type register: :class:`~.Register`
         :param value: Value to assign
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
@@ -145,68 +157,68 @@
 
         if isinstance(value, str):
             assert len(value.split("_")) == 2
 
         if self.get_register_value(register) is not None:
             self.unset_register(register)
 
-        self._register_values[0][register] = value
+        self._register_values[register] = value
 
-        if value in self._register_values[1]:
-            if register not in self._register_values[1][value]:
-                self._register_values[1][value].append(register)
+        if value in self._value_registers:
+            if register not in self._value_registers[value]:
+                self._value_registers[value].append(register)
         else:
-            self._register_values[1][value] = [register]
+            self._value_registers[value] = [register]
 
         # assert self.get_register_value(register) == value
-        # assert value in self._register_values[1].keys()
-        # assert self._register_values[0][register] == value
+        # assert value in self._value_registers.keys()
+        # assert self._register_values[register] == value
 
-    def get_closest_value(self, value):
+    def get_closest_value(self, value: int | float | Address | str):
         """Returns the closest value to the given value.
 
         Returns the closest value to the given value. If there are
         not values registered, `None` is returned.
 
         :param value: value to look for
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
 
         """
 
-        possible_regs = []
+        possible_regs: List[Tuple[Register, int | float | Address | str]] = []
 
-        for reg, val in self._register_values[0].items():
+        for reg, val in self._register_values.items():
 
             if not isinstance(val, type(value)):
                 continue
 
             possible_regs.append((reg, val))
 
         possible_regs = sorted(possible_regs,
                                key=lambda x: abs(x[1] - value))
         if possible_regs:
             return possible_regs[0]
 
         return None
 
-    def get_closest_address_value(self, address):
+    def get_closest_address_value(self, address: Address):
         """Returns the closest address to the given address.
 
         Returns the closest address to the given address. If there are
         not addresses registered, `None` is returned.
 
         :param address: Address to look for
         :type address: :class:`~.Address`
 
         """
 
-        possible_regs = []
+        possible_regs: List[Tuple[Register, Address]] = []
 
-        for reg, value in self._register_values[0].items():
+        for reg, value in self._register_values.items():
 
             if not isinstance(value, Address):
                 continue
 
             if Address(base_address=value.base_address) == \
                     Address(base_address=address.base_address):
                 possible_regs.append((reg, value))
@@ -215,30 +227,30 @@
                                key=lambda x: abs(x[1].displacement -
                                                  address.displacement))
         if possible_regs:
             return possible_regs[0]
 
         return None
 
-    def get_register_closest_value(self, value):
+    def get_register_closest_value(self, value: int | float | str):
         """Returns the register with the closest value to the given value.
 
         Returns the register with the closest value to the given value.
         If there are not values registered, `None` is returned.
         Address values are ignored.
 
         :param value: Value to look for
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
 
         """
 
-        possible_regs = []
+        possible_regs: List[Tuple[Register, int | float | str]] = []
 
-        for reg, reg_value in self._register_values[0].items():
+        for reg, reg_value in self._register_values.items():
 
             if isinstance(value, Address):
                 continue
 
             if not isinstance(reg_value, type(value)):
                 continue
 
@@ -256,236 +268,236 @@
                                                      int(value.split("_")[0])))
 
         if possible_regs:
             return possible_regs[0]
 
         return None
 
-    def get_register_value(self, register):
+    def get_register_value(self, register: Register):
         """Returns the register value. `None` if not found.
 
         :param register: Register to get its value
         :type register: :class:`~.Register`
 
         """
 
-        value = self._register_values[0].get(register, None)
+        value = self._register_values.get(register, None)
         if value is not None:
-            assert value in self._register_values[1].keys()
+            assert value in self._value_registers.keys()
 
         return value
 
-    def get_registername_value(self, register_name):
+    def get_registername_value(self, register_name: str):
         """Returns the register value. `None` if not found.
 
         :param register: Register name to get its value
         :type register: :class:`~.str`
         :param register_name:
 
         """
         assert isinstance(register_name, str)
 
-        register_names = [reg.name for reg in self._register_values[0]]
+        register_names = [reg.name for reg in self._register_values]
         if register_name not in register_names:
             return None
 
         register = [
-            reg for reg in self._register_values[0]
+            reg for reg in self._register_values
             if reg.name == register_name
         ][0]
 
-        return self._register_values[0].get(register, None)
+        return self._register_values.get(register, None)
 
-    def unset_registers(self, registers):
+    def unset_registers(self, registers: List[Register]):
         """Removes the values from registers.
 
         :param registers: List of registers
         :type registers: :class:`~.list` of :class:`~.Register`
 
         """
         for reg in registers:
             self.unset_register(reg)
 
-    def unset_register(self, register):
+    def unset_register(self, register: Register):
         """Remove the value from a register.
 
         :param register: Registers
         :type register: :class:`~.Register`
 
         """
 
-        assert self._register_values[0][register] is not None
+        assert self._register_values[register] is not None
 
-        value = self._register_values[0][register]
-        self._register_values[1][value].remove(register)
+        value = self._register_values[register]
+        self._value_registers[value].remove(register)
 
-        if not self._register_values[1][value]:
-            del self._register_values[1][value]
+        if not self._value_registers[value]:
+            del self._value_registers[value]
 
-        self._register_values[0][register] = None
+        self._register_values[register] = None
 
-    def set_memory_value(self, mem_value):
+    def set_memory_value(self, mem_value: MemoryValue):
         """Sets a memory value.
 
         :param mem_value: Memory value to set.
         :type mem_value: :class:`~.MemoryValue`
 
         """
 
         LOG.debug("Start set memory value: %s", mem_value)
 
         self.unset_memory(mem_value.address, mem_value.length)
-        self._memory_values[0][mem_value.address] = mem_value
+        self._memory_values[mem_value.address] = mem_value
 
-        if mem_value.value in self._memory_values[0]:
+        if mem_value.value in self._memory_values:
 
-            if mem_value not in self._memory_values[1][mem_value.value]:
+            if mem_value not in self._value_memorys[mem_value.value]:
 
-                self._memory_values[1][mem_value.value].append(mem_value)
+                self._value_memorys[mem_value.value].append(mem_value)
                 LOG.debug(
                     "Values inv %s: %s", mem_value.value,
-                    self._memory_values[1][mem_value.value]
+                    self._value_memorys[mem_value.value]
                 )
 
             else:
                 LOG.debug("Already in inv dictionary")
 
         else:
 
-            self._memory_values[1][mem_value.value] = [mem_value]
+            self._value_memorys[mem_value.value] = [mem_value]
             LOG.debug("Values inv %s: %s", mem_value.value, [mem_value])
 
-        assert self._memory_values[0][mem_value.address] == mem_value
-        assert mem_value in self._memory_values[1][mem_value.value]
+        assert self._memory_values[mem_value.address] == mem_value
+        assert mem_value in self._value_memorys[mem_value.value]
 
         LOG.debug("End set memory value: %s", mem_value)
 
-    def get_memory_value(self, address):
+    def get_memory_value(self, address: Address):
         """Gets a memory value.
 
         :param address: Address to look for
         :type address: :class:`~.Address`
 
         """
 
-        if address in self._memory_values[0]:
-            return self._memory_values[0][address]
+        if address in self._memory_values:
+            return self._memory_values[address]
 
         return None
 
-    def unset_memory(self, address, length):
+    def unset_memory(self, address: Address, length: int):
         """Unsets a memory region.
 
         :param address: Start address of the region
         :type address: :class:`~.Address`
         :param length: Length in bytes of the region
         :type length: :class:`~.int`
 
         """
 
         LOG.debug("Start unset address: %s (length: %s)", address, length)
 
         possible_addresses = [
             addr
-            for addr in self._memory_values[0]
+            for addr in self._memory_values
             if addr.base_address == address.base_address
         ]
 
         # LOG.debug("Possible addresses: %s", possible_addresses)
 
         for paddr in possible_addresses:
 
             diff = paddr - address
             diff2 = address - paddr
-            length2 = self._memory_values[0][paddr].length
+            length2 = self._memory_values[paddr].length
 
             if (
                     (diff >= 0 and diff < length) or
                     (diff2 >= 0 and diff2 < length2)
             ):
 
                 LOG.debug("Address overlap: %s", paddr)
-                mem_value = self._memory_values[0].pop(paddr)
+                mem_value = self._memory_values.pop(paddr)
 
                 LOG.debug("Memory value: %s", mem_value)
 
-                if mem_value in self._memory_values[1][mem_value.value]:
-                    self._memory_values[1][mem_value.value].remove(mem_value)
+                if mem_value in self._value_memorys[mem_value.value]:
+                    self._value_memorys[mem_value.value].remove(mem_value)
 
         LOG.debug("Finish unset address: %s (length: %s)", address, length)
 
-    def register_has_value(self, value):
+    def register_has_value(self, value: int | float | Address | str):
         """Returns if a value is in a register.
 
         :param value: Value to look for
         :type value: :class:`~.bool`
 
         """
-        return value in list([elem for elem in self._register_values[1].keys()
+        return value in list([elem for elem in self._value_registers.keys()
                              if type(elem) == type(value)])
 
-    def registers_get_value(self, value):
+    def registers_get_value(self, value: int | float | Address | str):
         """Gets a list of registers containing the specified value.
 
         :param value: Value to look for
         :type value: :class:`~.int` or :class:`~.float` or :class:`~.Address`
 
         """
 
-        keyl = [key for key in self._register_values[1] if key == value]
+        keyl = [key for key in self._value_registers if key == value]
 
         if len(keyl) != 1:
             assert keyl == 1
 
-        return self._register_values[1][keyl[0]]
+        return self._value_registers[keyl[0]]
 
     @property
     def register_values(self):
         """Dictionary of register, value pairs (:class:`~.dict`)"""
-        return self._register_values[0]
+        return self._register_values
 
     @property
     def reserved_registers(self):
         """List of reserved registers (:class:`~.list`)"""
         return list(self._reserved_registers.values())
 
     @property
     def data_segment(self):
         """Address starting the data segment (::class:`~.int`)"""
         return self._data_segment
 
-    def set_data_segment(self, value):
+    def set_data_segment(self, value: int):
         """Sets the data segment start address.
 
         :param value: Start address.
         :type value: ::class:`~.int`
 
         """
         self._data_segment = value
 
     @property
     def dat(self):
         """DAT object (:class:`~.DynamicAddressTranslation`"""
         return self._dat
 
-    def set_dat(self, dat):
+    def set_dat(self, dat: DynamicAddressTranslation):
         """Sets the dynamic address translation object.
 
         :param dat: DAT object.
         :type dat: :class:`~.DynamicAddressTranslation`
 
         """
         self._dat = dat
 
     @property
     def code_segment(self):
         """Address starting the code segment (::class:`~.int`)"""
         return self._code_segment
 
-    def set_code_segment(self, value):
+    def set_code_segment(self, value: int):
         """Sets the code segment start address.
 
         :param value: Start address.
         :type value: :class:`~.int`
 
         """
         self._code_segment = value
@@ -495,15 +507,15 @@
         """Boolean indicating if the context allows symbol labels
 
         Boolean indicating if the context allows symbol labels
         (:class:`~.bool`)
         """
         return self._symbolic
 
-    def set_symbolic(self, value):
+    def set_symbolic(self, value: bool):
         """Sets the symbolic property.
 
         :param value: Boolean indicating if the context allows symbol labels
         :type value: :class:`~.bool`
 
         """
         self._symbolic = value
@@ -513,63 +525,63 @@
         """Boolean indicating if absolute addresses are needed.
 
         Boolean indicating if absolute addresses are needed
         (:class:`~.bool`)
         """
         return self._fabsolute
 
-    def set_absolute(self, value):
+    def set_absolute(self, value: bool):
         """Sets the force_absolute property.
 
         :param value: Boolean indicating if absolute addresses are needed
         :type value: :class:`~.bool`
 
         """
         self._fabsolute = value
 
     # def _validate(self):
-    #     for register in self._register_values[0]:
-    #        value = self._register_values[0][register]
+    #     for register in self._register_values:
+    #        value = self._register_values[register]
     #        if value is not None:
-    #            assert register in self._register_values[1][value]
+    #            assert register in self._value_registers[value]
 
     def dump(self):
         """Return a dump of the current context status.
 
         Return a dump of the current context status. Very useful for pass
         debugging purposes.
 
 
         """
 
-        mstr = []
+        mstr: List[str] = []
         mstr.append("-" * 80)
         mstr.append("Context status:")
         mstr.append("Reserved Registers:")
 
         for key, value in sorted(self._reserved_registers.items()):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Registers values:")
-        for key, value in sorted(self._register_values[0].items()):
+        for key, value in sorted(self._register_values.items()):
             mstr.append("Idx:\t%s\tRaw Value:\t%s" % (key, value))
 
         mstr.append("Registers values inverted:")
         for key, value in sorted([
                     (str(k), str(v)) for k, v
-                    in self._register_values[1].items()
+                    in self._value_registers.items()
                 ]):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Memory values:")
-        for key, value in sorted(self._memory_values[0].items()):
+        for key, value in sorted(self._memory_values.items()):
             mstr.append("Idx:\t%s\tRaw Value:\t%s" % (key, value))
 
         mstr.append("Memory values inverted:")
-        for key, value in sorted(self._memory_values[1].items()):
+        for key, value in sorted(self._value_memorys.items()):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Code segment: %s" % self._code_segment)
         mstr.append("Data segment: %s" % self._data_segment)
         mstr.append("Symbolic context: %s" % self._symbolic)
 
         mstr.append("-" * 80)
```

## microprobe/definitions/generic/tools/mp_mpt2elf.py

```diff
@@ -38,26 +38,42 @@
 import microprobe.passes.structure
 import microprobe.passes.symbol
 import microprobe.passes.variable
 import microprobe.utils.cmdline
 from microprobe import MICROPROBE_RC
 from microprobe.code.address import Address, InstructionAddress
 from microprobe.code.context import Context
-from microprobe.code.ins import instruction_from_definition, \
-    instruction_to_definition
-from microprobe.exceptions import MicroprobeCodeGenerationError, \
-    MicroprobeException, MicroprobeMPTFormatError, MicroprobeValueError, \
-    MicroprobeRunCmdError
+from microprobe.code.ins import (
+    instruction_from_definition,
+    instruction_to_definition,
+)
+from microprobe.exceptions import (
+    MicroprobeCodeGenerationError,
+    MicroprobeException,
+    MicroprobeMPTFormatError,
+    MicroprobeValueError,
+    MicroprobeRunCmdError,
+)
 from microprobe.target import import_definition
 from microprobe.passes.instruction import SetInstructionOperandsByOpcodePass
-from microprobe.utils.asm import MicroprobeAsmInstructionDefinition,\
-    interpret_asm, instruction_to_asm_definition
+from microprobe.utils.asm import (
+    MicroprobeAsmInstructionDefinition,
+    interpret_asm,
+    instruction_to_asm_definition,
+)
 from microprobe.utils.bin import interpret_bin
-from microprobe.utils.cmdline import float_type, int_type, new_file_ext,\
-    print_error, print_info, print_warning, string_with_fields
+from microprobe.utils.cmdline import (
+    float_type,
+    int_type,
+    new_file_ext,
+    print_error,
+    print_info,
+    print_warning,
+    string_with_fields,
+)
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import Progress, twocs_to_int, findfiles
 from microprobe.utils.mpt import MicroprobeTestRegisterDefinition
 from microprobe.utils.run import run_cmd
 
 
 __author__ = "Ramon Bertran"
@@ -90,15 +106,15 @@
     overhead = 0
 
     if len(test_definition.dat_mappings) > 0:
         #
         # Assuming MPT generated from MAMBO full system
         #
         dat = target.get_dat(dat_map=test_definition.dat_mappings)
-        dat.control['DAT'] = True
+        dat.control["DAT"] = True
 
         for instr in test_definition.code:
             instr.address = dat.translate(instr.address, rev=True)
 
         # Address order might have changed after mapping
         test_definition.set_instruction_definitions(
             sorted(test_definition.code, key=lambda x: x.address)
@@ -122,19 +138,17 @@
                 test_definition.default_code_address, rev=True
             )
         if test_definition.default_data_address != 0:
             test_definition.default_data_address = dat.translate(
                 test_definition.default_data_address, rev=True
             )
         for access in test_definition.roi_memory_access_trace:
-            access.address = dat.translate(
-                access.address, rev=True
-            )
+            access.address = dat.translate(access.address, rev=True)
 
-    if 'raw_bin' in kwargs:
+    if "raw_bin" in kwargs:
         print_info("Interpreting RAW dump...")
 
         sequence = []
         raw_dict = {}
         current_address = 0
 
         # Assume state file provides the initial code address
@@ -142,48 +156,52 @@
         test_definition.set_default_code_address(0)
 
         executed_code = []
         align = 32
         for access in test_definition.roi_memory_access_trace:
             if access.data_type == "D":
                 continue
-            if ((access.address//align)*align) not in executed_code:
-                executed_code.append((access.address//align)*align)
+
+            if ((access.address // align) * align) not in executed_code:
+                executed_code.append((access.address // align) * align)
 
         for entry in test_definition.code:
-            if (not entry.assembly.upper().startswith("0X") and
-                    not entry.assembly.upper().startswith("0B")):
+            if not entry.assembly.upper().startswith(
+                "0X"
+            ) and not entry.assembly.upper().startswith("0B"):
                 raise MicroprobeMPTFormatError(
                     "This is not a RAW dump as it contains "
                     "assembly (%s)" % entry.assembly
                 )
 
             if entry.label is not None:
                 raise MicroprobeMPTFormatError(
                     "This is not a RAW dump as it contains "
                     "labels (%s)" % entry.label
                 )
 
-            if entry.decorators not in ['', ' ', None, []]:
+            if entry.decorators not in ["", " ", None, []]:
                 raise MicroprobeMPTFormatError(
                     "This is not a RAW dump as it contains "
                     "decorators (%s)" % entry.decorators
                 )
 
-            if entry.comments not in ['', ' ', None, []]:
+            if entry.comments not in ["", " ", None, []]:
                 raise MicroprobeMPTFormatError(
                     "This is not a RAW dump as it contains "
                     "comments (%s)" % entry.comments
                 )
 
             if entry.address is not None:
                 current_address = entry.address + displ
 
-            if (len(executed_code) > 0 and
-                    ((current_address//align)*align) not in executed_code):
+            if (
+                len(executed_code) > 0
+                and ((current_address // align) * align) not in executed_code
+            ):
                 continue
 
             if current_address not in raw_dict:
                 raw_dict[current_address] = ""
 
             # Assume that raw dump use a 4 bytes hex dump
             if len(entry.assembly) != 10:
@@ -192,103 +210,231 @@
                     "lines with other formats (%s)" % entry.assembly
                 )
 
             raw_dict[current_address] += entry.assembly[2:]
 
         if len(raw_dict) > 1:
             address_ant = sorted(raw_dict.keys())[0]
-            len_ant = len(raw_dict[address_ant])//2
+            len_ant = len(raw_dict[address_ant]) // 2
 
             # Assume that raw dump use a 4 bytes hex dump
             assert len_ant % 4 == 0
 
             for address in sorted(raw_dict.keys())[1:]:
                 if address_ant + len_ant == address:
                     raw_dict[address_ant] += raw_dict[address]
-                    len_ant = len(raw_dict[address_ant])//2
+                    len_ant = len(raw_dict[address_ant]) // 2
                     raw_dict.pop(address)
                 else:
-                    len_ant = len(raw_dict[address])//2
+                    len_ant = len(raw_dict[address]) // 2
                     address_ant = address
 
                 # Assume that raw dump use a 4 bytes hex dump
                 assert len_ant % 4 == 0
 
         sequence = []
         for address in sorted(raw_dict.keys()):
-
             # Endianess will be big endian, because we are concatenating
             # full words resulting in the higher bits being encoded first
 
             code = interpret_bin(
-                raw_dict[address], target, safe=True, little_endian=False,
-                word_length=4
+                raw_dict[address],
+                target,
+                safe=True,
+                little_endian=False,
+                word_length=4,
             )
 
             for instr in code:
                 instr.address = address
                 instr = instruction_from_definition(instr)
                 address = address + instr.architecture_type.format.length
                 instr = instruction_to_asm_definition(instr)
                 sequence.append(instr)
 
         test_definition.set_instruction_definitions(sequence)
 
     reset_steps = []
 
-    if 'no_wrap_test' not in kwargs:
-
+    if "no_wrap_test" not in kwargs:
         if test_definition.default_code_address != 0:
             print_error("Default code address should be zero")
             exit(-1)
 
         print_info("Wrapping function...")
         start_symbol = "START_TEST"
 
         init_address = test_definition.default_code_address
         for register in test_definition.registers:
             if register.name == "PC":
                 init_address = register.value
             if register.name == "PSW_ADDR":
                 init_address = register.value
 
+        if kwargs["fix_32bit_address"]:
+            base = kwargs["fix_32bit_address"]
+            print_info("Shifting addresses to belong to 32bit address space.")
+
+            elements_outside_range = []
+            for conj in [test_definition.code, test_definition.variables]:
+                for elem in conj:
+                    if elem.address is not None and elem.address >= 2**32:
+                        elements_outside_range.append(elem)
+
+            elements_outside_range = sorted(
+                elements_outside_range, key=lambda el: el.address
+            )
+
+            print(len(elements_outside_range))
+
+            print_info("Generating new mapping...")
+
+            mapping = {}
+            prev_mapped_address = None
+            prev_address = None
+            for elem in elements_outside_range:
+                if prev_address is None:
+                    next_address = base
+                else:
+                    offset = elem.address - prev_address
+                    if offset <= 256 * 4096:  # Respect offsets of nearby
+                        # pages to respect non-consecutive
+                        # and pc-relative page accesses
+                        next_address = prev_mapped_address + offset
+                    else:
+                        next_address = (prev_mapped_address & ~0xFFF) + 0x1000
+
+                mapping[elem.address] = next_address
+
+                prev_mapped_address = next_address
+                prev_address = elem.address
+
+            print_info(
+                "Address of last section: 0x%X "
+                % (mapping[elements_outside_range[-1].address])
+            )
+            print_info("Shifting %d elements " % (len(mapping)))
+
+            for elem in test_definition.code:
+                if elem.address in mapping:
+                    elem.address = mapping[elem.address]
+
+            prog = Progress(len(test_definition.variables))
+
+            for elem in test_definition.variables:
+                if elem.address in mapping:
+                    elem.address = mapping[elem.address]
+
+                for index in range(0, elem.num_elements, 8):
+                    value = int.from_bytes(
+                        elem.init_value[index: index + 8], "little"
+                    )
+                    page_addr = value & ~0xFFF
+                    if page_addr in mapping:
+                        new_value = mapping[page_addr] + (value & 0xFFF)
+                        bytes_ = int.to_bytes(new_value, 8, "little")
+                        for i, byte in enumerate(bytes_):
+                            elem.init_value[index + i] = byte
+                    elif value in mapping:
+                        new_value = mapping[value]
+                        bytes_ = int.to_bytes(new_value, 8, "little")
+                        for i, byte in enumerate(bytes_):
+                            elem.init_value[index + i] = byte
+
+                prog()
+
+            for register in test_definition.registers:
+                if register.value >= 2**32:
+                    if register.value in mapping:
+                        register.value = mapping[register.value]
+                    elif register.value & ~0xFFF in mapping:
+                        register.value = mapping[register.value & ~0xFFF] + (
+                            register.value & 0xFFF
+                        )
+                    else:
+                        print_warning(
+                            "Register %s's value is more than 32 bits but "
+                            "is not in mapping: %X"
+                            % (register.name, register.value)
+                        )
+                        closest_addr = None
+                        closest_dist = 8 * 1024  # Only consider mappings
+                        # 16kb apart
+                        for map_addr in mapping:
+                            dist = register.value - map_addr
+                            if abs(dist) < abs(closest_dist):
+                                closest_addr = map_addr
+                                closest_dist = dist
+                        if closest_addr is not None:
+                            print_warning(
+                                "  Closest mapped address: %X (distance: %d "
+                                "bytes). Applying shift. Final address: %X"
+                                % (
+                                    closest_addr,
+                                    closest_dist,
+                                    mapping[closest_addr] + closest_dist,
+                                )
+                            )
+                            register.value = (
+                                mapping[closest_addr] + closest_dist
+                            )
+
+            for access in test_definition.roi_memory_access_trace:
+                if access.address in mapping:
+                    access.address = mapping[access.address]
+                else:
+                    page_addr = access.address & ~0xFFF
+                    if page_addr in mapping:
+                        access.address = mapping[page_addr] + (
+                            access.address & 0xFFF
+                        )
+                    elif page_addr > 2**32:
+                        print_warning(
+                            "Access is more than 32 bits but is "
+                            "not in mapping: %x" % access.address
+                        )
+
         displacements = []
         for elem in test_definition.code:
             if elem.address is not None:
                 if len(displacements) == 0:
                     displacements.append(
-                        (elem.address, 4*1024, elem.address - init_address)
+                        (elem.address, 4 * 1024, elem.address - init_address)
                     )
                 else:
                     displacements.append(
-                        (elem.address, elem.address - displacements[-1][0],
-                         elem.address - init_address)
+                        (
+                            elem.address,
+                            elem.address - displacements[-1][0],
+                            elem.address - init_address,
+                        )
                     )
 
         # Get ranges with enough space to put init code
         # Assuming 4K space is enough
         displacements = [
-            displ for displ in displacements
-            if displ[1] >= 4*1024 and displ[2] <= 0
+            displ
+            for displ in displacements
+            if displ[1] >= 4 * 1024 and displ[2] <= 0
         ]
 
         if len(displacements) == 0:
             print_error(
                 "Unable to find space for the initialization code. "
                 "Check the mpt initial code address or state of PC "
                 "for correctness."
             )
             exit(-1)
 
         displ_fixed = False
-        if kwargs['fix_start_address']:
-            displacement = kwargs['fix_start_address']
+        if kwargs["fix_start_address"]:
+            displacement = kwargs["fix_start_address"]
             print_info("Start point set to 0x%X" % displacement)
             displ_fixed = True
-        elif 'fix_long_jump' in kwargs:
+        elif "fix_long_jump" in kwargs:
             displacement = sorted(displacements, key=lambda x: x[0])[0][0]
             if displacement > 2**32:
                 displacement = 0x1000000
                 print_info("Start point set to 0x%X" % displacement)
                 displ_fixed = True
         else:
             displacement = sorted(displacements, key=lambda x: x[2])[-1][0]
@@ -317,63 +463,69 @@
             start_symbol = test_definition.code[0].label
 
         if displacement is None:
             displacement = 0
 
         instructions = []
         reset_steps = []
-        if 'wrap_endless' in kwargs and 'reset' in kwargs:
 
+        if "wrap_endless" in kwargs and "reset" in kwargs:
             target.scratch_var.set_address(
-                Address(
-                    base_address=target.scratch_var.name
-                )
+                Address(base_address=target.scratch_var.name)
             )
 
             new_ins, overhead, reset_steps = _compute_reset_code(
                 target,
                 test_definition,
                 kwargs,
             )
             instructions += new_ins
 
-        if 'fix_long_jump' in kwargs:
-            instructions += target.function_call(
-                init_address,
-                long_jump=True
-            )
+        instructions += target.hook_before_test_instructions()
+
+        if "fix_long_jump" in kwargs:
+            instructions += target.function_call(init_address, long_jump=True)
         else:
             instructions += target.function_call(
                 ("%s" % start_symbol).replace("+0x-", "-0x"),
             )
 
-        if 'wrap_endless' not in kwargs:
-            instructions += [target.nop()]
-        else:
+        instructions += target.hook_after_test_instructions()
+
+        if "wrap_endless" in kwargs:
+            instructions += target.hook_after_reset_instructions()  # TODO fix
             instructions += _compute_reset_jump(target, instructions)
 
+        instructions += target.hook_test_end_instructions()
+
         instructions_definitions = []
         for instruction in instructions:
             instruction.set_label(None)
 
             if not displ_fixed:
-                displacement = (displacement -
-                                instruction.architecture_type.format.length)
+                displacement = (
+                    displacement - instruction.architecture_type.format.length
+                )
 
             current_instruction = MicroprobeAsmInstructionDefinition(
-                instruction.assembly(), None, None, None, instruction.comments,
+                instruction.assembly(),
+                None,
+                None,
+                None,
+                instruction.comments,
             )
             instructions_definitions.append(current_instruction)
 
         instruction = target.nop()
         instruction.set_label(None)
 
         if not displ_fixed:
-            displacement = (displacement -
-                            instruction.architecture_type.format.length)
+            displacement = (
+                displacement - instruction.architecture_type.format.length
+            )
 
         # To avoid overlaps
         if not displ_fixed:
             align = 0x100
             displacement = ((displacement // align) + 0) * align
 
         instructions_definitions[0].address = displacement
@@ -401,108 +553,116 @@
             )
 
             for elem in test_definition.code:
                 if elem.address is not None:
                     elem.address = elem.address - displacement
 
         else:
-            test_definition.set_default_code_address(
-                displacement
-            )
+            test_definition.set_default_code_address(displacement)
             for elem in test_definition.code:
                 if elem.address is not None:
                     elem.address = elem.address - displacement
 
     variables = test_definition.variables
-    variables = [var for var in test_definition.variables
-                 if var.address is None or var.address >= 0x00100000]
+    variables = [
+        var
+        for var in test_definition.variables
+        if var.address is None or var.address >= 0x00100000
+    ]
 
     test_definition.set_variables_definition(variables)
 
     print_info("Interpreting asm ...")
 
     sequence_orig = interpret_asm(
-        test_definition.code, target,
+        test_definition.code,
+        target,
         [var.name for var in variables] + [target.scratch_var.name],
         show_progress=True,
     )
 
     if len(sequence_orig) < 1:
         raise MicroprobeMPTFormatError(
             "No instructions found in the 'instructions' entry of the MPT"
             " file. Check the input file.",
         )
 
     raw = test_definition.raw
-    raw['FILE_FOOTER'] = "# mp_mpt2elf: Wrapping overhead: %03.2f %%" \
-                         % overhead
+    raw["FILE_FOOTER"] = (
+        "# mp_mpt2elf: Wrapping overhead: %03.2f %%" % overhead
+    )
 
     # end_address = end_address_orig
     ckwargs = {
         # 'end_address': end_address,
         # 'reset': False,
         # 'endless': 'endless' in kwargs
     }
 
     wrapper_name = "AsmLd"
 
     if test_definition.default_data_address is not None:
-        ckwargs['init_data_address'] = \
-            test_definition.default_data_address
+        ckwargs["init_data_address"] = test_definition.default_data_address
 
     if test_definition.default_code_address is not None:
-        ckwargs['init_code_address'] = \
-            test_definition.default_code_address
+        ckwargs["init_code_address"] = test_definition.default_code_address
 
     try:
         code_wrapper = microprobe.code.get_wrapper(wrapper_name)
     except MicroprobeValueError as exc:
         raise MicroprobeException(
             "Wrapper '%s' not available. Check if you have the wrappers"
             " of the target installed or set up an appropriate "
             "MICROPROBEWRAPPERS environment variable. Original error "
-            "was: %s" %
-            (wrapper_name, str(exc)),
+            "was: %s" % (wrapper_name, str(exc)),
         )
 
     wrapper = code_wrapper(**ckwargs)
 
     print_info("Setup synthesizer ...")
     synthesizer = microprobe.code.Synthesizer(
-        target, wrapper, no_scratch=False,
+        target,
+        wrapper,
+        no_scratch=True,
         extra_raw=raw,
     )
 
     variables = test_definition.variables
     registers = test_definition.registers
     sequence = sequence_orig
 
-    if len(registers) >= 0:
+    synthesizer.add_pass(
+        microprobe.passes.initialization.AddInitializationInstructionsPass(
+            target.hook_test_init_instructions()
+        ),
+    )
 
-        cr_reg = [
-            register for register in registers if register.name == "CR"
-        ]
+    if len(registers) >= 0:
+        cr_reg = [register for register in registers if register.name == "CR"]
 
         registers = [
             register for register in registers if register.name != "CR"
         ]
 
         if cr_reg:
             value = cr_reg[0].value
             for idx in range(0, 8):
                 cr = MicroprobeTestRegisterDefinition(
                     "CR%d" % idx,
                     (value >> (28 - (idx * 4))) & 0xF,
-                    )
+                )
                 registers.append(cr)
 
         synthesizer.add_pass(
             microprobe.passes.initialization.InitializeRegistersPass(
-                registers, skip_unknown=True, warn_unknown=True,
-                skip_control=True, force_reserved=True
+                registers,
+                skip_unknown=True,
+                warn_unknown=True,
+                skip_control=True,
+                force_reserved=True,
             ),
         )
 
     synthesizer.add_pass(
         microprobe.passes.structure.SimpleBuildingBlockPass(
             len(sequence),
         ),
@@ -515,18 +675,21 @@
     )
 
     synthesizer.add_pass(
         microprobe.passes.instruction.ReproduceSequencePass(sequence),
     )
 
     if target.name.startswith("power"):
-        fix_branches = [instr.name for instr in target.instructions.values()
-                        if instr.branch_conditional]
+        fix_branches = [
+            instr.name
+            for instr in target.instructions.values()
+            if instr.branch_conditional
+        ]
 
-        if 'raw_bin' in kwargs:
+        if "raw_bin" in kwargs:
             # We do not know what is code and what is data, so we safely
             # disable the asm generation and keep the values
             for orig in [21, 17, 19]:
                 synthesizer.add_pass(
                     microprobe.passes.instruction.DisableAsmByOpcodePass(
                         fix_branches, 0, ifval=orig
                     )
@@ -551,30 +714,29 @@
             microprobe.passes.memory.FixMemoryReferencesPass(
                 reset_registers=kwargs.get("fix_memory_registers", False),
             ),
         )
 
         synthesizer.add_pass(
             microprobe.passes.register.FixRegistersPass(
-                forbid_writes=['GPR3'],
+                forbid_writes=["GPR3"],
             ),
         )
 
     if kwargs.get("fix_memory_registers", False):
         print_info("Fix memory registers: On")
         synthesizer.add_pass(
             microprobe.passes.register.NoHazardsAllocationPass(),
         )
 
     if kwargs.get("fix_branch_next", False):
         print_info("Force branch to next: On")
         synthesizer.add_pass(
             microprobe.passes.address.UpdateInstructionAddressesPass(
-                force="fix_flatten_code" in kwargs,
-                noinit=True
+                force="fix_flatten_code" in kwargs, noinit=True
             )
         )
         synthesizer.add_pass(
             microprobe.passes.branch.BranchNextPass(force=True),
         )
 
     if kwargs.get("fix_indirect_branches", False):
@@ -597,22 +759,19 @@
         microprobe.passes.address.UpdateInstructionAddressesPass(
             noinit=True,
             init_from_first=not displ_fixed,
         ),
     )
 
     synthesizer.add_pass(
-        microprobe.passes.variable.UpdateVariableAddressesPass(
-        ),
+        microprobe.passes.variable.UpdateVariableAddressesPass(),
     )
 
     synthesizer.add_pass(
-        microprobe.passes.symbol.ResolveSymbolicReferencesPass(
-            onlyraw=True
-        ),
+        microprobe.passes.symbol.ResolveSymbolicReferencesPass(onlyraw=True),
     )
 
     print_info("Start synthesizer ...")
     bench = synthesizer.synthesize()
 
     # Save the microbenchmark
     synthesizer.save(output_file, bench=bench)
@@ -621,58 +780,69 @@
 
     _compile(output_file, target, **kwargs)
 
     return
 
 
 def _compile(filename, target, **kwargs):
-
     if "compiler" not in kwargs:
         print_info("Compiler not provided")
         print_info("To compiler the code, first extract the custom")
         print_info("ld script embedded in the assembly as comments to do")
         print_info("so execute:")
         print_info("grep 'MICROPROBE LD' %s | cut -d '@' -f 2" % filename)
         print_info("then compile using gcc and providing the ld script")
         print_info("using the -T option.")
         return
 
     print_info("Compiling %s ..." % filename)
 
-    outputname = ".".join(filename.split(".")[:-1]+["elf"])
-    ldscriptname = ".".join(filename.split(".")[:-1]+["ldscript"])
+    outputname = ".".join(filename.split(".")[:-1] + ["elf"])
+    ldscriptname = ".".join(filename.split(".")[:-1] + ["ldscript"])
 
     fdout = open(ldscriptname, "w")
     fdin = open(filename, "r")
     for line in fdin.readlines():
         if "MICROPROBE LD" in line:
             line = line.split("@")[1]
             fdout.write(line)
     fdout.close()
     fdin.close()
 
     try:
         baseldscriptname = findfiles(
-            MICROPROBE_RC['template_paths'],
-            "%s.ldscript" % target.name
+            MICROPROBE_RC["template_paths"], "%s.ldscript" % target.name
         )[0]
     except IndexError:
-        print_error("Unable to find template ld script: %s.ldscript" %
-                    target.name)
+        print_error(
+            "Unable to find template ld script: %s.ldscript" % target.name
+        )
         exit(-1)
 
+    routines_name = None
+
+    try:
+        routines_name = findfiles(
+            MICROPROBE_RC["template_paths"], "%s_routines.s" % target.name
+        )[0]
+    except IndexError:
+        pass
+
     cprog = kwargs["compiler"]
 
     cflags = " -o %s" % outputname
     cflags += " -T %s" % ldscriptname
     cflags += " -T %s " % baseldscriptname
     cflags += kwargs["compiler_flags"]
     # We only support BFD linker
     cflags += " -fuse-ld=bfd "
 
+    if routines_name is not None:
+        cflags += " " + routines_name
+
     cmd = "%s %s %s" % (cprog, cflags, filename)
 
     print_info("Executing compilation command")
     print_info("%s" % cmd)
     try:
         run_cmd(cmd)
         print_info("'%s' generated!" % outputname)
@@ -681,21 +851,25 @@
         cmd = "%s %s %s" % (cprog, cflags, filename)
         print_info("Executing compilation command (statically)")
         print_info("%s" % cmd)
         try:
             run_cmd(cmd)
             print_info("'%s' generated!" % outputname)
         except MicroprobeRunCmdError:
-            print_info("'%s' not generated due compilation"
-                       " issues. Try manual compilation." % outputname)
+            print_info(
+                "'%s' not generated due compilation"
+                " issues. Try manual compilation." % outputname
+            )
 
 
 def _compute_reset_code(target, test_def, args):
     instructions = interpret_asm(
-        test_def.code, target, [var.name for var in test_def.variables],
+        test_def.code,
+        target,
+        [var.name for var in test_def.variables],
         show_progress=True,
     )
 
     # TODO: This can be done in parallel or look for speed up the process
     instructions = [
         instruction_from_definition(instr) for instr in instructions
     ]
@@ -706,16 +880,17 @@
         len(test_def.roi_memory_access_trace),
         msg="Building instruction dictionary",
     )
     for instr in instructions:
         progress()
         if instr.address is not None:
             if instr.address.base_address == "code":
-                address = test_def.default_code_address + \
-                          instr.address.displacement
+                address = (
+                    test_def.default_code_address + instr.address.displacement
+                )
                 instr.set_address(address)
         else:
             address = address + instr.architecture_type.format.length
             instr.set_address(address)
         instruction_dict[instr.address] = instr
 
     free_regs = []
@@ -755,30 +930,32 @@
             level += 1
         elif instr.mnemonic == "BCCTRL":
             if instr.operands()[2].value in [0, 3]:
                 level += 1
 
         # POWER Returns
         if instr.mnemonic == "BCLR":
-            if (((instr.operands()[0].value & 0b10100) == 20) and
-                    (instr.operands()[2].value == 0)):
+            if ((instr.operands()[0].value & 0b10100) == 20) and (
+                instr.operands()[2].value == 0
+            ):
                 level -= 1
 
         # Z Calls
         if instr.mnemonic == "BRASL":
-            if (instr.operands()[0].value == target.registers["GR14"]):
+            if instr.operands()[0].value == target.registers["GR14"]:
                 level += 1
         if instr.mnemonic == "BASR":
-            if (instr.operands()[0].value == target.registers["GR14"]):
+            if instr.operands()[0].value == target.registers["GR14"]:
                 level += 1
 
         # Z Returns
         if instr.mnemonic == "BCR":
-            if ((instr.operands()[1].value == target.registers["GR14"]) and
-                    (instr.operands()[0].value == 15)):
+            if (instr.operands()[1].value == target.registers["GR14"]) and (
+                instr.operands()[0].value == 15
+            ):
                 level -= 1
 
         # TODO: this should include RISCV instructions for call
         # and return, but currently we do not have memory access traces
         # for such platforms
 
         for reg in uses:
@@ -803,15 +980,16 @@
     assert len(set(free_regs).intersection(set(reset_regs))) == 0
 
     if len(test_def.roi_memory_access_trace) == 0:
         # We do not have memory access trace, assume calling conventions
         reset_regs = target.volatile_registers
 
     reset_regs = [
-        reg for reg in reset_regs if reg in target.volatile_registers]
+        reg for reg in reset_regs if reg in target.volatile_registers
+    ]
 
     if len(reset_regs) == 0 and len(test_def.roi_memory_access_trace) == 0:
         print_info(
             "No memory access trace found. Resetting volatile registers."
         )
         reset_regs = target.volatile_registers
 
@@ -864,57 +1042,53 @@
                     raise NotImplementedError
                 end_address = var.address + var.num_elements * elem_size
                 if var.address <= address < end_address:
                     offset = int((address - var.address) / elem_size)
                     svalue = var.init_value[
                         offset:offset + int(value[0] / elem_size)
                     ]
-                    svalue = "".join(["%02X" % tval for tval in svalue])
+                    svalue = "".join(
+                        reversed(["%02X" % tval for tval in svalue])
+                    )  # TODO: Reverse ONLY on little endian archs
                     wvalue = int(svalue, 16)
                     break
 
             if wvalue is None:
                 print_error(
-                    "Unable to restore original value for address 0x%X" %
-                    address,
+                    "Unable to restore original value for address 0x%X"
+                    % address,
                 )
                 exit(1)
 
             if value[0] <= 8:
                 fix_addresses.append((address, value[0], wvalue))
             else:
-                for selem in range(0, value[0]//8):
-                    sfmt = "%%0%dX" % (2*value[0])
+                for selem in range(0, value[0] // 8):
+                    sfmt = "%%0%dX" % (2 * value[0])
                     nvalue = sfmt % wvalue
-                    nvalue = int(nvalue[selem*16:(selem+1)*16], 16)
-                    fix_addresses.append(
-                        (address + selem * 8,
-                         8,
-                         nvalue)
-                    )
+                    nvalue = int(nvalue[selem * 16:(selem + 1) * 16], 16)
+                    fix_addresses.append((address + selem * 8, 8, nvalue))
 
     reset_steps = []
 
     context = Context()
     context.set_symbolic(True)
 
     if len(fix_addresses) > 0:
-
         # TODO: This can be optimized. Reduce the number of instructions to
         # be added by sorting the reset code (shared values or similar
         # addresses)
         # TODO: This can be optimized for use vector registers when
         # needed
         #
         print_info("Adding instructions to reset memory state")
         reset_registers = [
             reg
             for reg in free_regs
-            if reg.type.used_for_address_arithmetic and
-            reg.name != "GPR0"
+            if reg.type.used_for_address_arithmetic and reg.name != "GPR0"
         ]
 
         if len(reset_registers) == 0:
             print_error(
                 "No free register available for resetting memory"
                 " contentents."
             )
@@ -924,121 +1098,143 @@
         zero_register = None
 
         if len(reset_registers) > 1:
             # Set a register to zero, which is always useful for
             # address computation
             zero_register = reset_registers[1]
             new_instructions = target.set_register(
-                zero_register, 0, context, opt=False,
+                zero_register,
+                0,
+                context,
+                opt=False,
             )
             for ins in new_instructions:
                 ins.add_comment(
-                    "Reset code. Setting %s to 0X%016X" %
-                    (zero_register.name, 0),
+                    "Reset code. Setting %s to 0X%016X"
+                    % (zero_register.name, 0),
                 )
             reset_steps.append([new_instructions[:], zero_register, 0])
             context.set_register_value(zero_register, 0)
             new_ins.extend(new_instructions)
 
         for address, length, value in fix_addresses:
-
             address_obj = Address(base_address="data", displacement=address)
             new_instructions = target.set_register(
-                reset_register, value, context, opt=False,
+                reset_register,
+                value,
+                context,
+                opt=False,
             )
 
             for ins in new_instructions:
                 ins.add_comment(
-                    "Reset code. Setting %s to 0X%016X" %
-                    (reset_register.name, value),
+                    "Reset code. Setting %s to 0X%016X"
+                    % (reset_register.name, value),
                 )
 
             reset_steps.append([new_instructions[:], reset_register, value])
             context.set_register_value(reset_register, value)
 
             try:
                 store_ins = target.store_integer(
-                    reset_register, address_obj, length * 8, context,
+                    reset_register,
+                    address_obj,
+                    length * 8,
+                    context,
                 )
                 new_instructions += store_ins
                 reset_steps.append(
                     [store_ins, reset_register, address_obj, length],
                 )
 
             except MicroprobeCodeGenerationError:
                 areg = [
-                    reg for reg in free_regs
-                    if reg.type.used_for_address_arithmetic and reg.name !=
-                    "GPR0" and reg != reset_register and reg != zero_register
+                    reg
+                    for reg in free_regs
+                    if reg.type.used_for_address_arithmetic
+                    and reg.name != "GPR0"
+                    and reg != reset_register
+                    and reg != zero_register
                 ][0]
 
                 set_ins = target.set_register(
-                    areg, address, context, opt=False,
+                    areg,
+                    address,
+                    context,
+                    opt=False,
                 )
                 new_instructions += set_ins
                 reset_steps.append([set_ins, areg, address_obj])
 
                 context.set_register_value(areg, address_obj)
 
                 store_ins = target.store_integer(
-                    reset_register, address_obj, length * 8, context,
+                    reset_register,
+                    address_obj,
+                    length * 8,
+                    context,
                 )
                 new_instructions += store_ins
                 reset_steps.append(
                     [store_ins, reset_register, address_obj, length],
                 )
 
                 for ins in set_ins:
                     ins.add_comment(
-                        "Reset code. Setting %s to 0X%016X" %
-                        (areg.name, address),
+                        "Reset code. Setting %s to 0X%016X"
+                        % (areg.name, address),
                     )
 
             for ins in store_ins:
                 ins.add_comment(
                     "Reset code. Setting mem content in 0X%016X" % (address),
-                    )
+                )
 
             new_ins.extend(new_instructions)
 
     # Reset contents of used registers
     for reset_register in reset_regs:
         try:
             value = [
-                reg for reg in test_def.registers if reg.name ==
-                reset_register.name
+                reg
+                for reg in test_def.registers
+                if reg.name == reset_register.name
             ][0].value
         except IndexError:
             continue
 
         new_instructions = target.set_register(
-            reset_register, value, context, opt=False,
+            reset_register,
+            value,
+            context,
+            opt=False,
         )
         reset_steps.append([new_instructions, reset_register, value])
         context.set_register_value(reset_register, value)
 
         for ins in new_instructions:
             ins.add_comment(
-                "Reset code. Setting %s to 0X%016X" %
-                (reset_register.name, value),
+                "Reset code. Setting %s to 0X%016X"
+                % (reset_register.name, value),
             )
 
         new_ins.extend(new_instructions)
 
     try:
-        overhead = (((len(new_ins) * 1.0) / dynamic_count) * 100)
+        overhead = ((len(new_ins) * 1.0) / dynamic_count) * 100
     except ZeroDivisionError:
-        print_warning("Unable to compute overhead. Zero dynamic instruction "
-                      "count")
+        print_warning(
+            "Unable to compute overhead. Zero dynamic instruction " "count"
+        )
         overhead = 0
 
     print_info(
         "%03.2f%% overhead added by resetting code" % overhead,
     )
-    if overhead > args['wrap_endless_threshold']:
+    if overhead > args["wrap_endless_threshold"]:
         print_error(
             "Instructions added: %d" % len(new_ins),
         )
         print_error(
             "Total instructions: %d" % dynamic_count,
         )
         print_error(
@@ -1047,45 +1243,48 @@
         exit(1)
 
     return new_ins, overhead, reset_steps
 
 
 def _compute_reset_jump(target, instrs):
     source_instruction = InstructionAddress(
-        base_address="code", displacement=0,
+        base_address="code",
+        displacement=0,
     )
 
     displacement = 0
     for instr in instrs:
         displacement = displacement - instr.architecture_type.format.length
 
     target_instruction = InstructionAddress(
-        base_address="code", displacement=displacement,
+        base_address="code",
+        displacement=displacement,
+    )
+
+    return target.branch_unconditional_relative2(
+        source_instruction,
+        target_instruction,
     )
-    return [
-        target.branch_unconditional_relative(
-            source_instruction, target_instruction,
-        ),
-    ]
 
 
 # Main
 def main():
     """Program main."""
     args = sys.argv[1:]
     cmdline = microprobe.utils.cmdline.CLI(
         "MicroprobeTest (mpt) to ELF tool",
         mpt_options=True,
         default_config_file="mp_mpt2elf.cfg",
-        force_required=['target'],
+        force_required=["target"],
     )
 
     group_name = "MPT to ELF arguments"
     cmdline.add_group(
-        group_name, "Command arguments related to MPT to ELF tool",
+        group_name,
+        "Command arguments related to MPT to ELF tool",
     )
 
     cmdline.add_option(
         "elf-output-file",
         "O",
         None,
         "ELF output file name",
@@ -1112,57 +1311,70 @@
 
     group_name = "Fixing options"
     cmdline.add_group(
         group_name,
         "Command arguments related to fixing options",
     )
     cmdline.add_flag(
-        "fix-indirect-branches", None, "Fix branches without known target",
+        "fix-indirect-branches",
+        None,
+        "Fix branches without known target",
         group_name,
     )
     cmdline.add_flag(
-        "fix-branch-next", None, "Force target of branches to be the next "
-                                 "sequential instruction",
+        "fix-branch-next",
+        None,
+        "Force target of branches to be the next " "sequential instruction",
         group_name,
     )
     cmdline.add_flag(
-        "fix-memory-references", None,
+        "fix-memory-references",
+        None,
         "Ensure that registers used by instructions accessing "
-        "storage are initialized to valid locations", group_name,
+        "storage are initialized to valid locations",
+        group_name,
     )
     cmdline.add_flag(
-        "fix-memory-registers", None,
+        "fix-memory-registers",
+        None,
         "Fix non-storage instructions touching registers used for"
         " storage address computations (implies "
-        "--fix-memory-references flag)", group_name,
+        "--fix-memory-references flag)",
+        group_name,
     )
     cmdline.add_flag(
-        "fix-flatten-code", None,
+        "fix-flatten-code",
+        None,
         "All code is flatten using consecutive addresses",
         group_name,
     )
     cmdline.add_flag(
-        "safe-bin", None, "Ignore unrecognized binary codifications (do not"
-                          "fail). Useful when MPTs are generated by dumping "
-                          "directly code "
-                          "pages, which contain padding zeros and other "
-                          "non-code stuff)",
+        "safe-bin",
+        None,
+        "Ignore unrecognized binary codifications (do not"
+        "fail). Useful when MPTs are generated by dumping "
+        "directly code "
+        "pages, which contain padding zeros and other "
+        "non-code stuff)",
         group_name,
     )
     cmdline.add_flag(
-        "raw-bin", None, "Process all instruction entries together. They "
-                         "all shoud be binary entries. Implies --safe-bin "
-                         "flag. Useful when MPTs are generated by dumping "
-                         "directly code "
-                         "pages, which contain padding zeros and other "
-                         "non-code stuff)",
+        "raw-bin",
+        None,
+        "Process all instruction entries together. They "
+        "all shoud be binary entries. Implies --safe-bin "
+        "flag. Useful when MPTs are generated by dumping "
+        "directly code "
+        "pages, which contain padding zeros and other "
+        "non-code stuff)",
         group_name,
     )
     cmdline.add_flag(
-        "fix-long-jump", None,
+        "fix-long-jump",
+        None,
         "Sometimes the generated code is unable compile due a long jump "
         "displacement required to jump to the start insturction.",
         group_name,
     )
 
     cmdline.add_option(
         "fix-start-address",
@@ -1170,34 +1382,52 @@
         None,
         "Sometimes the user requires the main start point to be on specific "
         "address to avoid compilation issues or comply with the execution "
         "environment requirements. This flag forces the main entry point of "
         "execution to be at the specified address. It is up to the user to "
         "define a proper entry point that does not clash with existing code.",
         group=group_name,
-        opt_type=int_type(0, 2**64)
+        opt_type=int_type(0, 2**64),
+    )
+
+    cmdline.add_option(
+        "fix-32bit-address",
+        "X",
+        None,
+        "Sometimes the user requires the addresses of the content to be "
+        "within a 32bit address space. However, a test may incorporate "
+        "content outside of that address space. This flag forces the "
+        "variables to be shifted to fit within this limit, starting at the "
+        "specified address. It is up to the user to define a proper starting "
+        "address that does not clash with the existing code.",
+        group=group_name,
+        opt_type=int_type(0, 2**32),
     )
 
     group_name = "Wrapping options"
     cmdline.add_group(
         group_name,
         "Command arguments related to wrapping options",
     )
     cmdline.add_flag(
-        "no-wrap-test", None, "By default the code is wrapped like it was "
-                              "a function call, use this flag to disable the "
-                              "wrapping",
+        "no-wrap-test",
+        None,
+        "By default the code is wrapped like it was "
+        "a function call, use this flag to disable the "
+        "wrapping",
         group_name,
     )
     cmdline.add_flag(
-        "wrap-endless", None, "Use this flag to wrap the code in an endless "
-                              "loop assuming it is a function. "
-                              "If needed (--reset option), additional "
-                              "instructions are added to reset the "
-                              "the initial state between loop iterations. ",
+        "wrap-endless",
+        None,
+        "Use this flag to wrap the code in an endless "
+        "loop assuming it is a function. "
+        "If needed (--reset option), additional "
+        "instructions are added to reset the "
+        "the initial state between loop iterations. ",
         group_name,
     )
     cmdline.add_option(
         "wrap-endless-threshold",
         None,
         1,
         "Maximum percentage of instructions allowed in the reset code if "
@@ -1206,16 +1436,18 @@
         "code of the test case."
         " Default is 1%%.",
         group=group_name,
         opt_type=float_type(0, 1000),
         required=False,
     )
     cmdline.add_flag(
-        "reset", None, "Use this flag to enable the generation of reset "
-                       "code if wrap-endless is enabled.",
+        "reset",
+        None,
+        "Use this flag to enable the generation of reset "
+        "code if wrap-endless is enabled.",
         group_name,
     )
 
     print_info("Processing input arguments...")
     cmdline.main(args, _main)
 
 
@@ -1224,38 +1456,39 @@
 
     :param arguments: Dictionary with command line arguments and values
     :type arguments: :class:`dict`
     """
     print_info("Arguments processed!")
     print_info("Importing target definition...")
 
-    if 'raw_bin' in arguments:
-        arguments['safe_bin'] = True
+    if "raw_bin" in arguments:
+        arguments["safe_bin"] = True
 
-    if 'safe_bin' in arguments:
-        microprobe.MICROPROBE_RC['safe_bin'] = True
+    if "safe_bin" in arguments:
+        microprobe.MICROPROBE_RC["safe_bin"] = True
 
-    if 'fix_start_address' not in arguments:
-        arguments['fix_start_address'] = None
+    if "fix_start_address" not in arguments:
+        arguments["fix_start_address"] = None
+
+    if "fix_32bit_address" not in arguments:
+        arguments["fix_32bit_address"] = None
 
     if "no_wrap_test" in arguments and "wrap_endless" in arguments:
         print_error(
             "--no-wrap-test specified and --wrap-endless specified. "
             "Incompatible options."
         )
 
-    target = import_definition(arguments.pop('target'))
-    test_definition = arguments['mpt_definition']
-    output_file = arguments['elf_output_file']
+    target = import_definition(arguments.pop("target"))
+    test_definition = arguments["mpt_definition"]
+    output_file = arguments["elf_output_file"]
 
     print_info("Start generating '%s'" % output_file)
-    generate(
-        test_definition, output_file, target, **arguments
-    )
+    generate(test_definition, output_file, target, **arguments)
 
 
-if __name__ == '__main__':  # run main if executed from the command line
+if __name__ == "__main__":  # run main if executed from the command line
     # and the main method exists
 
-    if callable(locals().get('main')):
+    if callable(locals().get("main")):
         main()
         exit(0)
```

## microprobe/definitions/generic/wrappers/asmld.py

```diff
@@ -291,15 +291,15 @@
                     ",".join(["0x%s" % hstr[idx:idx + 2]
                               for idx in reversed(range(2, len(hstr), 2))])
                 )
             else:
                 asm.append(
                     ".byte " +
                     ",".join(["0x%s" % hstr[idx:idx + 2]
-                              for idx in range(0, len(hstr), 2)])
+                              for idx in reversed(range(0, len(hstr), 2))])
                 )
             asm = " ".join(asm)
         else:
             asm = instr.assembly()
 
         if instr.comments:
             bstr = " " * len(asm) + " /* "
```

## microprobe/passes/initialization/__init__.py

```diff
@@ -466,15 +466,15 @@
 
 
 class AddInitializationInstructionsPass(microprobe.passes.Pass):
     """AddInitializationInstructionsPass pass.
 
     """
 
-    def __init__(self, instr, operands):
+    def __init__(self, instr, operands=None):
         """
 
         :param instr:
         :param operands:
 
         """
         super(AddInitializationInstructionsPass, self).__init__()
@@ -489,22 +489,26 @@
         """
 
         :param building_block:
         :param dummy_target:
 
         """
 
-        for instr, operands in zip(self._instr, self._operands):
-            newinstr = microprobe.code.ins.Instruction()
-            # print instr
-            # print self._instr
-            newinstr.set_arch_type(instr)
-            newinstr.set_operands(operands)
-            # print operands
-            building_block.add_init([newinstr])
+        if self._operands is not None:
+            for instr, operands in zip(self._instr, self._operands):
+                newinstr = microprobe.code.ins.Instruction()
+                # print instr
+                # print self._instr
+                newinstr.set_arch_type(instr)
+                newinstr.set_operands(operands)
+                # print operands
+                building_block.add_init([newinstr])
+        else:
+            for instr in self._instr:
+                building_block.add_init([instr])
 
 
 class AutoAlignPass(microprobe.passes.Pass):
     """AutoAlignPass pass.
 
     """
```

## microprobe/target/env/__init__.py

```diff
@@ -260,14 +260,39 @@
         raise NotImplementedError
 
     @abc.abstractproperty
     def target(self):
         """ """
         raise NotImplementedError
 
+    @abc.abstractmethod
+    def hook_before_test_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_after_test_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_test_init_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_after_reset_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_test_end_instructions(self):
+        """ """
+        raise NotImplementedError
+
 
 class GenericEnvironment(Environment):
     """ """
 
     _cmp_attributes = ["name", "descr"]
 
     def __init__(self, name, descr, isa, little_endian=False):
@@ -486,7 +511,27 @@
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if getattr(self, attr) >= getattr(other, attr):
                 continue
             else:
                 return False
         return True
+
+    def hook_before_test_instructions(self):
+        """ """
+        return []
+
+    def hook_after_test_instructions(self):
+        """ """
+        return [self._target.nop()]
+
+    def hook_test_init_instructions(self):
+        """ """
+        return []
+
+    def hook_after_reset_instructions(self):
+        """ """
+        return []
+
+    def hook_test_end_instructions(self):
+        """ """
+        return []
```

## Comparing `microprobe_core-0.5.20220906104555.dist-info/LICENSE` & `microprobe_core-0.5.20230629114852.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `microprobe_core-0.5.20220906104555.dist-info/METADATA` & `microprobe_core-0.5.20230629114852.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: microprobe-core
-Version: 0.5.20220906104555
+Version: 0.5.20230629114852
 Summary: Microprobe: Microbenchmark generation framework: Main package
 Home-page: https://github.com/IBM/microprobe
 Author: Ramon Bertran
 Author-email: rbertra@us.ibm.com
 Maintainer: Ramon Bertran
 Maintainer-email: rbertra@us.ibm.com
 License: Apache Version 2.0
```

## Comparing `microprobe_core-0.5.20220906104555.dist-info/entry_points.txt` & `microprobe_core-0.5.20230629114852.dist-info/entry_points.txt`

 * *Files identical despite different names*

## Comparing `microprobe_core-0.5.20220906104555.dist-info/RECORD` & `microprobe_core-0.5.20230629114852.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 microprobe/__init__.py,sha256=gSvzR35UxVDNKb8HJdFvOSbRcZd99tceH_aKZBgC7uI,9236
 microprobe/exceptions.py,sha256=nBz7iho1-56vWCt3RcmdB3N-VH64GtrmpffjBDtG9A0,6504
-microprobe/microprobe.cfg,sha256=IYeaqRzYM6Zer3R646Fgy7S9jQw8Eu8XjhQPvNolUNk,772
+microprobe/microprobe.cfg,sha256=qhObTmwuBae4J6AY6bxGNRBvQhXUyJliW3BPWmawDtE,772
 microprobe/property.py,sha256=9QmP2rA40FOifkQ5gnFjek2xzv2Buyr5XzP884W0ELg,10213
 microprobe/code/__init__.py,sha256=w8k-i1mSqc_s2X4fIg3JnvWYBzJvgbRo4OIoRJokFn0,25912
 microprobe/code/address.py,sha256=WWjtOLHHMTIMsQzlphuZTofyg5O7zMYWGqhFB6D52BQ,14640
 microprobe/code/bbl.py,sha256=xfQ2jHY0F83ZjVw6UM2E8sOuB4k5eYImhkdYKbEFNJY,11088
 microprobe/code/benchmark.py,sha256=2U2Kj4_9M6BBPDNIf__HudTk-HgF-EK8t6LXbuFpk3Q,14023
 microprobe/code/cfg.py,sha256=1BQ3tdeVIdfZYlTbH36bC0htXAFPOuNk1phnLvpDXMI,3379
-microprobe/code/context.py,sha256=VK7v6OWt9ID87rJ1bk-k5j5tqxRNQXZigSyP9k1uiZA,17316
+microprobe/code/context.py,sha256=VKRRKnPh4z4ZTenooDlWtw9GsiS-X0446n3aDwr2-28,18207
 microprobe/code/ins.py,sha256=TaGe7uCH_y3elWX79wtjlf_jXzFE5ewQzF204MnO_Ws,74582
 microprobe/code/var.py,sha256=FcwHFccukhU_y2-AAmiUNs6Fkrd5bPANIXa7WbrVZIk,11674
 microprobe/code/wrapper.py,sha256=PQWFxnGJYeEzPpAw7_vVv3ASQ6bLcs2VTUoGHNzPHfw,5909
 microprobe/definitions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/generic/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/generic/policies/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/generic/policies/debug.py,sha256=jetJNIc6W_HDHrmKBDcdQNLP9AJuiYxw2Xg3iwQ-EbI,2919
@@ -21,23 +21,23 @@
 microprobe/definitions/generic/templates/c2mpt_template.c,sha256=jeg1Mr-ulmDfNGv42t6yNuFyivVHfrX9kw7_2pMP_TI,3595
 microprobe/definitions/generic/tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/generic/tools/mp_bin2asm.py,sha256=8CZzJlA0j0poppg1X0ULeNHvQJBBv2ABefztOizU-Iw,3598
 microprobe/definitions/generic/tools/mp_bin2objdump.py,sha256=PpwLCgxZYMahfdX8RPmRloosMhmYwc69aKorYzUnIXs,7592
 microprobe/definitions/generic/tools/mp_c2mpt.py,sha256=OFSN04Qhr3NDG2DLZh55Yw3dLDTz_i1GV0yfwASTZKs,18592
 microprobe/definitions/generic/tools/mp_epi.py,sha256=wuLc1VudO8-tvMdj4WYfo-ErCx0fTrHKxoBom7gh-gI,12632
 microprobe/definitions/generic/tools/mp_mpt2bin.py,sha256=N3NqD6Ef75YT0QE-A-bB8EyabySgObhYOzbxj8SLlN0,37529
-microprobe/definitions/generic/tools/mp_mpt2elf.py,sha256=WZZkk27BrY7P904h9i740ajnI2q6tBGc1Zw3k1tp6So,42126
+microprobe/definitions/generic/tools/mp_mpt2elf.py,sha256=1W26D_6zuHXZzxO8-yryma7W1pIazAGsyXRQ3zMBGyY,49314
 microprobe/definitions/generic/tools/mp_mpt2test.py,sha256=oGol5980ITst09PUh4rTWX_5mH_u51_moB2OWfCrtXg,11772
 microprobe/definitions/generic/tools/mp_objdump2mpt.py,sha256=9X29rUu6PXMHP6i7fjHLtqb754O1jqAGybTSV0MZlJs,9698
 microprobe/definitions/generic/tools/mp_seq.py,sha256=_6XwcCIp-gj5TJFfcK4Rnk_Wacl3imgwaJiyXYdZ8JU,21242
 microprobe/definitions/generic/tools/mp_seqtune.py,sha256=RTfcEsZJa2vmL3bDZxsL3lKsiJ7g603zIaN5qfHnFxA,26322
 microprobe/definitions/generic/tools/mp_target.py,sha256=q3imR2hKSk0hCCtB5SE9_N9P2ox_KBuE-MUdm5kyfJw,3321
 microprobe/definitions/generic/wrappers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/generic/wrappers/asm.py,sha256=xu6mxjhjKa3Xym5bVhGNNavQHAGk4pnoPpBkUBOzZpk,3568
-microprobe/definitions/generic/wrappers/asmld.py,sha256=BFrMGsreYREiypBHoX7ezspKXGM4mMv-NyONRKXtDVk,10928
+microprobe/definitions/generic/wrappers/asmld.py,sha256=_5OVbKGEYaFTPwGmlUri26dgjhmOOx7haPydHqHewD8,10938
 microprobe/definitions/generic/wrappers/bin.py,sha256=6o342iJGf7faEonCOl8UQSuftrGM_xyR3EEhnvUe4Eg,5723
 microprobe/definitions/generic/wrappers/c.py,sha256=8wkRJzdpBUmLioVMzgYstQYSBMVXieuH8VGfIm3OK18,17830
 microprobe/definitions/generic/wrappers/cpapi.py,sha256=uAVBIYQIYH1S0SK8IF5tNoHm30w6C2lO0hJIC7F_s20,19973
 microprobe/definitions/generic/wrappers/debug.py,sha256=gdk6HBCX_JaDc2qk17fGKLvmnW2euFVLBZ58TvEG2fU,4480
 microprobe/definitions/generic/wrappers/trace.py,sha256=GkKD9Sw8kuNwDAJaN0uWNFmekCV5QEfQbrTw0hSJNJQ,7605
 microprobe/driver/__init__.py,sha256=TaAuxqdWA5dvHoznIgZJ9cLEIbvAROJZjf24MkGTv5k,671
 microprobe/driver/genetic.py,sha256=pYWkGu-dJFSMaCfnk1LWgwiRskBrWRyusk_gQ1jZC90,10949
@@ -47,26 +47,26 @@
 microprobe/passes/__init__.py,sha256=6ceMHZUDbOhR4_mSSHY43yDH6hl-pK9mTrNcnhSHX2k,2180
 microprobe/passes/address/__init__.py,sha256=AJApvRvHOchD2Fy9E5-XGHfcshFxx1ok0go8c0CBSvU,7684
 microprobe/passes/branch/__init__.py,sha256=PxQIteOsacSLIRVzIHn1W79Nb02ZLq6YlSxqRv7xY8o,58027
 microprobe/passes/dat/__init__.py,sha256=l9mEItBt58OI7tQh0CorAilF2t6J1JRvGdzS4QUpJJU,2527
 microprobe/passes/decimal/__init__.py,sha256=tXBqRpa-HSfxZi61hjWD3YaMZ4_a-AzP6BvhJtfOgRs,3028
 microprobe/passes/float/__init__.py,sha256=B3DMgvmgJOBTQX511End8QEWLvpQHO4hgDrbnWoKAQU,6533
 microprobe/passes/ilp/__init__.py,sha256=MTxI3YMsiP6QSG82iiYdP1kIGiDJ5l9nYqInFxfs_P0,3129
-microprobe/passes/initialization/__init__.py,sha256=SdW9xuanvmwUOy7YuCtOqSNuz6oxlpRBJN2lJHqYqG4,17355
+microprobe/passes/initialization/__init__.py,sha256=YQd9G0afMVBd2bvr7tzlD947Wsk0ioTTnn97bSzRPvo,17532
 microprobe/passes/instruction/__init__.py,sha256=Ddio2x6J4yxKodFwf7oTpaudB6PkO6IaR43F1z3P9kg,45784
 microprobe/passes/memory/__init__.py,sha256=GU6rav5eNi37OEsKr2NLcOj3-qxBBputCKcqWo1SECg,106225
 microprobe/passes/register/__init__.py,sha256=1rzpVnbEc5eDtzYQxeUHeOMCnNDeAIgBOx2xDKk9kZU,39864
 microprobe/passes/structure/__init__.py,sha256=s1gHg2_GumC-EsQ5BfWwXxAfgaP-ufAlMRYmpLtBbMs,7658
 microprobe/passes/switch/__init__.py,sha256=jiGdt2SYylyx2zVzkOhytLrXCfzkKtEDyvlIopHpVFA,28125
 microprobe/passes/symbol/__init__.py,sha256=PDi4DS3Vda6FoVxHnd8Nuw_HpYTJQgiud6Y3eftChzA,11544
 microprobe/passes/variable/__init__.py,sha256=e5uB6_t71B6axZ3KVcfWdg8mTOXkw7AofeTIWeXZTh4,7484
 microprobe/schemas/__init__.py,sha256=Ux-r6dlnsCasIE7luA9Fh-YCwDFwPdxVw-XC_loO1cY,710
 microprobe/schemas/property.yaml,sha256=SO6RbUv33ssnjxbOjQHLFhOLeQii-QwZKhmqV3dgYeE,1310
 microprobe/target/__init__.py,sha256=dDYNhEHpA4lCvqfsxcOcL__tzXKvB0beHbEp7PsUHgY,19638
-microprobe/target/env/__init__.py,sha256=3S8M52aJUzOChXQCEoxzkak9Upjhq2-nuDG6hw_1zeE,12398
+microprobe/target/env/__init__.py,sha256=-AkeaQgcpF-9UDCJi7yRScKlRUZ_miLmfZzgvKgWLfQ,13404
 microprobe/target/isa/__init__.py,sha256=3XkrUI-O_7XattffRnGbZ6RQycLUGNydk_wk77W5zmE,26085
 microprobe/target/isa/comparator.py,sha256=v4jDBZp6oTT1cPq5r1cnbwLEtfFh5SuNa2nqDksr4OM,4486
 microprobe/target/isa/dat.py,sha256=fbkB-hSaY1TmtMmVfY7-mX8aKMhd-mbM_QaI0AwcA4o,6482
 microprobe/target/isa/generator.py,sha256=RBAfOadKX-B_W6ZxwxAxk_5puX5fu_uV6a6oOka21m8,3506
 microprobe/target/isa/instruction.py,sha256=EMBZHCzsLLDBDgVK9D8I0F9AD39TUq18N_FMH29MbIY,66656
 microprobe/target/isa/instruction_field.py,sha256=ZJXvZicyp1AoIeAjLMsMyHSq1EhCuAQ8OHnlKW7BYAU,5783
 microprobe/target/isa/instruction_format.py,sha256=gN1ib2trFjid20DAil48Wqd9cckWBQTY--olAh1U_F4,12051
@@ -105,13 +105,13 @@
 microprobe/utils/misc.py,sha256=7JOQ_OGpOvt6gGuukgNuu7q0IfxUm5WmeTirjKllohg,14194
 microprobe/utils/mpt.py,sha256=6CjAQlz8aAuemZSS7TFY0DDImwgLIscLTdSk8zQloYU,72494
 microprobe/utils/objdump.py,sha256=xkr0ZZJsRZ7kjFNUCTsq5DjjeCE5fnAN4qadYC3-Crw,11342
 microprobe/utils/policy.py,sha256=YwuOJjN6_v4dTLET691QjgHoI-GxBwpX5KxMBRmCiQU,2718
 microprobe/utils/profile.py,sha256=L3O0cEbcYUHOM9DKEulhCTmLKadhWp7CMWHMuhk2seU,1169
 microprobe/utils/run.py,sha256=ymTUlbRtXeqy8taojUaZtqXny5xcoTXx_Fn5DltTN14,2869
 microprobe/utils/yaml.py,sha256=qy4XXg0ySNZ1YanaX3a-eA41-A7IrLLP0bR4ajh0U1M,5319
-microprobe_core-0.5.20220906104555.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
-microprobe_core-0.5.20220906104555.dist-info/METADATA,sha256=SHK6L5JBO5094mWYyd2ZZj3pIVwlHZfVpePa5iudt5g,1820
-microprobe_core-0.5.20220906104555.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
-microprobe_core-0.5.20220906104555.dist-info/entry_points.txt,sha256=qKejWJv50zo1L8EkFGz6BT7i-YKSUL_puW8yd9x3IPc,740
-microprobe_core-0.5.20220906104555.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
-microprobe_core-0.5.20220906104555.dist-info/RECORD,,
+microprobe_core-0.5.20230629114852.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
+microprobe_core-0.5.20230629114852.dist-info/METADATA,sha256=UX5g2S9vLJ6ajcIo1B-aHoUgpF40qslbCbE4VCVBqrg,1820
+microprobe_core-0.5.20230629114852.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+microprobe_core-0.5.20230629114852.dist-info/entry_points.txt,sha256=qKejWJv50zo1L8EkFGz6BT7i-YKSUL_puW8yd9x3IPc,740
+microprobe_core-0.5.20230629114852.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
+microprobe_core-0.5.20230629114852.dist-info/RECORD,,
```

