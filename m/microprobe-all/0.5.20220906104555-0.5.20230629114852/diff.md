# Comparing `tmp/microprobe_all-0.5.20220906104555-py2.py3-none-any.whl.zip` & `tmp/microprobe_all-0.5.20230629114852-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,76 +1,76 @@
-Zip file size: 254570 bytes, number of entries: 74
--rw-r--r--  2.0 unx     9236 b- defN 22-Jul-27 13:33 microprobe/__init__.py
--rw-r--r--  2.0 unx     6504 b- defN 22-Jul-27 13:33 microprobe/exceptions.py
--rw-r--r--  2.0 unx    10213 b- defN 22-Jul-27 13:33 microprobe/property.py
--rw-r--r--  2.0 unx    25912 b- defN 22-Jul-27 13:33 microprobe/code/__init__.py
--rw-r--r--  2.0 unx    14640 b- defN 22-Jul-27 13:33 microprobe/code/address.py
--rw-r--r--  2.0 unx    11088 b- defN 22-Jul-27 13:33 microprobe/code/bbl.py
--rw-r--r--  2.0 unx    14023 b- defN 22-Jul-27 13:33 microprobe/code/benchmark.py
--rw-r--r--  2.0 unx     3379 b- defN 22-Jul-27 13:33 microprobe/code/cfg.py
--rw-r--r--  2.0 unx    17316 b- defN 22-Jul-27 13:33 microprobe/code/context.py
--rw-r--r--  2.0 unx    74582 b- defN 22-Jul-27 13:33 microprobe/code/ins.py
--rw-r--r--  2.0 unx    11674 b- defN 22-Jul-27 13:33 microprobe/code/var.py
--rw-r--r--  2.0 unx     5909 b- defN 22-Jul-27 13:33 microprobe/code/wrapper.py
--rw-r--r--  2.0 unx      671 b- defN 22-Jul-27 13:33 microprobe/driver/__init__.py
--rw-r--r--  2.0 unx    10949 b- defN 22-Jul-27 13:33 microprobe/driver/genetic.py
--rw-r--r--  2.0 unx      677 b- defN 22-Jul-27 13:33 microprobe/driver/guided.py
--rw-r--r--  2.0 unx     1642 b- defN 22-Jul-27 13:33 microprobe/model/__init__.py
--rw-r--r--  2.0 unx    13892 b- defN 22-Jul-27 13:33 microprobe/model/memory.py
--rw-r--r--  2.0 unx     2180 b- defN 22-Jul-27 13:33 microprobe/passes/__init__.py
--rw-r--r--  2.0 unx     7684 b- defN 22-Jul-27 13:33 microprobe/passes/address/__init__.py
--rw-r--r--  2.0 unx    58027 b- defN 22-Sep-06 14:43 microprobe/passes/branch/__init__.py
--rw-r--r--  2.0 unx     2527 b- defN 22-Jul-27 13:33 microprobe/passes/dat/__init__.py
--rw-r--r--  2.0 unx     3028 b- defN 22-Jul-27 13:33 microprobe/passes/decimal/__init__.py
--rw-r--r--  2.0 unx     6533 b- defN 22-Jul-27 13:33 microprobe/passes/float/__init__.py
--rw-r--r--  2.0 unx     3129 b- defN 22-Jul-27 13:33 microprobe/passes/ilp/__init__.py
--rw-r--r--  2.0 unx    17355 b- defN 22-Jul-27 13:33 microprobe/passes/initialization/__init__.py
--rw-r--r--  2.0 unx    45784 b- defN 22-Jul-27 13:33 microprobe/passes/instruction/__init__.py
--rw-r--r--  2.0 unx   106225 b- defN 22-Sep-06 14:43 microprobe/passes/memory/__init__.py
--rw-r--r--  2.0 unx    39864 b- defN 22-Jul-27 13:33 microprobe/passes/register/__init__.py
--rw-r--r--  2.0 unx     7658 b- defN 22-Jul-27 13:33 microprobe/passes/structure/__init__.py
--rw-r--r--  2.0 unx    28125 b- defN 22-Jul-27 13:33 microprobe/passes/switch/__init__.py
--rw-r--r--  2.0 unx    11544 b- defN 22-Jul-27 13:33 microprobe/passes/symbol/__init__.py
--rw-r--r--  2.0 unx     7484 b- defN 22-Jul-27 13:33 microprobe/passes/variable/__init__.py
--rw-r--r--  2.0 unx      710 b- defN 22-Jul-27 13:33 microprobe/schemas/__init__.py
--rw-r--r--  2.0 unx    19638 b- defN 22-Jul-27 13:33 microprobe/target/__init__.py
--rw-r--r--  2.0 unx    12398 b- defN 22-Jul-27 13:33 microprobe/target/env/__init__.py
--rw-r--r--  2.0 unx    26085 b- defN 22-Sep-06 14:43 microprobe/target/isa/__init__.py
--rw-r--r--  2.0 unx     4486 b- defN 22-Jul-27 13:33 microprobe/target/isa/comparator.py
--rw-r--r--  2.0 unx     6482 b- defN 22-Jul-27 13:33 microprobe/target/isa/dat.py
--rw-r--r--  2.0 unx     3506 b- defN 22-Jul-27 13:33 microprobe/target/isa/generator.py
--rw-r--r--  2.0 unx    66656 b- defN 22-Jul-27 13:33 microprobe/target/isa/instruction.py
--rw-r--r--  2.0 unx     5783 b- defN 22-Jul-27 13:33 microprobe/target/isa/instruction_field.py
--rw-r--r--  2.0 unx    12051 b- defN 22-Jul-27 13:33 microprobe/target/isa/instruction_format.py
--rw-r--r--  2.0 unx    42994 b- defN 22-Jul-27 13:33 microprobe/target/isa/operand.py
--rw-r--r--  2.0 unx     9736 b- defN 22-Jul-27 13:33 microprobe/target/isa/register.py
--rw-r--r--  2.0 unx     8284 b- defN 22-Jul-27 13:33 microprobe/target/isa/register_type.py
--rw-r--r--  2.0 unx      710 b- defN 22-Jul-27 13:33 microprobe/target/isa/schemas/__init__.py
--rw-r--r--  2.0 unx    11307 b- defN 22-Jul-27 13:33 microprobe/target/uarch/__init__.py
--rw-r--r--  2.0 unx    14318 b- defN 22-Jul-27 13:33 microprobe/target/uarch/cache.py
--rw-r--r--  2.0 unx    13221 b- defN 22-Jul-27 13:33 microprobe/target/uarch/element.py
--rw-r--r--  2.0 unx     4498 b- defN 22-Jul-27 13:33 microprobe/target/uarch/element_type.py
--rw-r--r--  2.0 unx      710 b- defN 22-Jul-27 13:33 microprobe/target/uarch/schemas/__init__.py
--rw-r--r--  2.0 unx      670 b- defN 22-Jul-27 13:33 microprobe/utils/__init__.py
--rw-r--r--  2.0 unx    46408 b- defN 22-Sep-06 14:43 microprobe/utils/asm.py
--rw-r--r--  2.0 unx    33575 b- defN 22-Sep-06 14:43 microprobe/utils/bin.py
--rw-r--r--  2.0 unx     6526 b- defN 22-Sep-06 14:43 microprobe/utils/cache.py
--rw-r--r--  2.0 unx    56510 b- defN 22-Sep-06 14:43 microprobe/utils/cmdline.py
--rw-r--r--  2.0 unx    18127 b- defN 22-Jul-27 13:33 microprobe/utils/config.py
--rw-r--r--  2.0 unx    10924 b- defN 22-Jul-27 13:33 microprobe/utils/distrib.py
--rw-r--r--  2.0 unx     3092 b- defN 22-Jul-27 13:33 microprobe/utils/ieee.py
--rw-r--r--  2.0 unx     8536 b- defN 22-Jul-27 13:33 microprobe/utils/imp.py
--rw-r--r--  2.0 unx     2545 b- defN 22-Jul-27 13:33 microprobe/utils/info.py
--rw-r--r--  2.0 unx     3055 b- defN 22-Jul-27 13:33 microprobe/utils/logger.py
--rw-r--r--  2.0 unx    14194 b- defN 22-Jul-27 13:33 microprobe/utils/misc.py
--rw-r--r--  2.0 unx    72494 b- defN 22-Sep-06 14:43 microprobe/utils/mpt.py
--rw-r--r--  2.0 unx    11342 b- defN 22-Jul-27 13:33 microprobe/utils/objdump.py
--rw-r--r--  2.0 unx     2718 b- defN 22-Jul-27 13:33 microprobe/utils/policy.py
--rw-r--r--  2.0 unx     1169 b- defN 22-Jul-27 13:33 microprobe/utils/profile.py
--rw-r--r--  2.0 unx     2869 b- defN 22-Jul-27 13:33 microprobe/utils/run.py
--rw-r--r--  2.0 unx     5319 b- defN 22-Jul-27 13:33 microprobe/utils/yaml.py
--rw-rw-r--  2.0 unx    11356 b- defN 22-Sep-06 14:45 microprobe_all-0.5.20220906104555.dist-info/LICENSE
--rw-r--r--  2.0 unx     1875 b- defN 22-Sep-06 14:45 microprobe_all-0.5.20220906104555.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 22-Sep-06 14:45 microprobe_all-0.5.20220906104555.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 22-Sep-06 14:45 microprobe_all-0.5.20220906104555.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6545 b- defN 22-Sep-06 14:45 microprobe_all-0.5.20220906104555.dist-info/RECORD
-74 files, 1162997 bytes uncompressed, 244216 bytes compressed:  79.0%
+Zip file size: 254909 bytes, number of entries: 74
+-rw-r--r--  2.0 unx     9236 b- defN 23-Jun-21 21:07 microprobe/__init__.py
+-rw-r--r--  2.0 unx     6504 b- defN 23-Jun-21 21:07 microprobe/exceptions.py
+-rw-r--r--  2.0 unx    10213 b- defN 23-Jun-21 21:07 microprobe/property.py
+-rw-r--r--  2.0 unx    25912 b- defN 23-Jun-21 21:07 microprobe/code/__init__.py
+-rw-r--r--  2.0 unx    14640 b- defN 23-Jun-21 21:07 microprobe/code/address.py
+-rw-r--r--  2.0 unx    11088 b- defN 23-Jun-21 21:07 microprobe/code/bbl.py
+-rw-r--r--  2.0 unx    14023 b- defN 23-Jun-21 21:07 microprobe/code/benchmark.py
+-rw-r--r--  2.0 unx     3379 b- defN 23-Jun-21 21:07 microprobe/code/cfg.py
+-rw-r--r--  2.0 unx    18207 b- defN 23-Jun-21 22:19 microprobe/code/context.py
+-rw-r--r--  2.0 unx    74582 b- defN 23-Jun-21 21:07 microprobe/code/ins.py
+-rw-r--r--  2.0 unx    11674 b- defN 23-Jun-21 21:07 microprobe/code/var.py
+-rw-r--r--  2.0 unx     5909 b- defN 23-Jun-21 21:07 microprobe/code/wrapper.py
+-rw-r--r--  2.0 unx      671 b- defN 23-Jun-21 21:07 microprobe/driver/__init__.py
+-rw-r--r--  2.0 unx    10949 b- defN 23-Jun-21 21:07 microprobe/driver/genetic.py
+-rw-r--r--  2.0 unx      677 b- defN 23-Jun-21 21:07 microprobe/driver/guided.py
+-rw-r--r--  2.0 unx     1642 b- defN 23-Jun-21 21:07 microprobe/model/__init__.py
+-rw-r--r--  2.0 unx    13892 b- defN 23-Jun-21 21:07 microprobe/model/memory.py
+-rw-r--r--  2.0 unx     2180 b- defN 23-Jun-21 21:07 microprobe/passes/__init__.py
+-rw-r--r--  2.0 unx     7684 b- defN 23-Jun-21 21:07 microprobe/passes/address/__init__.py
+-rw-r--r--  2.0 unx    58027 b- defN 23-Jun-21 21:07 microprobe/passes/branch/__init__.py
+-rw-r--r--  2.0 unx     2527 b- defN 23-Jun-21 21:07 microprobe/passes/dat/__init__.py
+-rw-r--r--  2.0 unx     3028 b- defN 23-Jun-21 21:07 microprobe/passes/decimal/__init__.py
+-rw-r--r--  2.0 unx     6533 b- defN 23-Jun-21 21:07 microprobe/passes/float/__init__.py
+-rw-r--r--  2.0 unx     3129 b- defN 23-Jun-21 21:07 microprobe/passes/ilp/__init__.py
+-rw-r--r--  2.0 unx    17532 b- defN 23-Jun-21 22:53 microprobe/passes/initialization/__init__.py
+-rw-r--r--  2.0 unx    45784 b- defN 23-Jun-21 21:07 microprobe/passes/instruction/__init__.py
+-rw-r--r--  2.0 unx   106225 b- defN 23-Jun-21 21:07 microprobe/passes/memory/__init__.py
+-rw-r--r--  2.0 unx    39864 b- defN 23-Jun-21 21:07 microprobe/passes/register/__init__.py
+-rw-r--r--  2.0 unx     7658 b- defN 23-Jun-21 21:07 microprobe/passes/structure/__init__.py
+-rw-r--r--  2.0 unx    28125 b- defN 23-Jun-21 21:07 microprobe/passes/switch/__init__.py
+-rw-r--r--  2.0 unx    11544 b- defN 23-Jun-21 21:07 microprobe/passes/symbol/__init__.py
+-rw-r--r--  2.0 unx     7484 b- defN 23-Jun-21 21:07 microprobe/passes/variable/__init__.py
+-rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/schemas/__init__.py
+-rw-r--r--  2.0 unx    19638 b- defN 23-Jun-21 21:07 microprobe/target/__init__.py
+-rw-r--r--  2.0 unx    13404 b- defN 23-Jun-21 22:53 microprobe/target/env/__init__.py
+-rw-r--r--  2.0 unx    26085 b- defN 23-Jun-21 21:07 microprobe/target/isa/__init__.py
+-rw-r--r--  2.0 unx     4486 b- defN 23-Jun-21 21:07 microprobe/target/isa/comparator.py
+-rw-r--r--  2.0 unx     6482 b- defN 23-Jun-21 21:07 microprobe/target/isa/dat.py
+-rw-r--r--  2.0 unx     3506 b- defN 23-Jun-21 21:07 microprobe/target/isa/generator.py
+-rw-r--r--  2.0 unx    66656 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction.py
+-rw-r--r--  2.0 unx     5783 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction_field.py
+-rw-r--r--  2.0 unx    12051 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction_format.py
+-rw-r--r--  2.0 unx    42994 b- defN 23-Jun-21 21:07 microprobe/target/isa/operand.py
+-rw-r--r--  2.0 unx     9736 b- defN 23-Jun-21 21:07 microprobe/target/isa/register.py
+-rw-r--r--  2.0 unx     8284 b- defN 23-Jun-21 21:07 microprobe/target/isa/register_type.py
+-rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/__init__.py
+-rw-r--r--  2.0 unx    11307 b- defN 23-Jun-21 21:07 microprobe/target/uarch/__init__.py
+-rw-r--r--  2.0 unx    14318 b- defN 23-Jun-21 21:07 microprobe/target/uarch/cache.py
+-rw-r--r--  2.0 unx    13221 b- defN 23-Jun-21 21:07 microprobe/target/uarch/element.py
+-rw-r--r--  2.0 unx     4498 b- defN 23-Jun-21 21:07 microprobe/target/uarch/element_type.py
+-rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/target/uarch/schemas/__init__.py
+-rw-r--r--  2.0 unx      670 b- defN 23-Jun-21 21:07 microprobe/utils/__init__.py
+-rw-r--r--  2.0 unx    46408 b- defN 23-Jun-21 21:07 microprobe/utils/asm.py
+-rw-r--r--  2.0 unx    33575 b- defN 23-Jun-21 21:07 microprobe/utils/bin.py
+-rw-r--r--  2.0 unx     6526 b- defN 23-Jun-21 21:07 microprobe/utils/cache.py
+-rw-r--r--  2.0 unx    56510 b- defN 23-Jun-21 21:07 microprobe/utils/cmdline.py
+-rw-r--r--  2.0 unx    18127 b- defN 23-Jun-21 21:07 microprobe/utils/config.py
+-rw-r--r--  2.0 unx    10924 b- defN 23-Jun-21 21:07 microprobe/utils/distrib.py
+-rw-r--r--  2.0 unx     3092 b- defN 23-Jun-21 21:07 microprobe/utils/ieee.py
+-rw-r--r--  2.0 unx     8536 b- defN 23-Jun-21 21:07 microprobe/utils/imp.py
+-rw-r--r--  2.0 unx     2545 b- defN 23-Jun-21 21:07 microprobe/utils/info.py
+-rw-r--r--  2.0 unx     3055 b- defN 23-Jun-21 21:07 microprobe/utils/logger.py
+-rw-r--r--  2.0 unx    14194 b- defN 23-Jun-21 21:07 microprobe/utils/misc.py
+-rw-r--r--  2.0 unx    72494 b- defN 23-Jun-21 21:07 microprobe/utils/mpt.py
+-rw-r--r--  2.0 unx    11342 b- defN 23-Jun-21 21:07 microprobe/utils/objdump.py
+-rw-r--r--  2.0 unx     2718 b- defN 23-Jun-21 21:07 microprobe/utils/policy.py
+-rw-r--r--  2.0 unx     1169 b- defN 23-Jun-21 21:07 microprobe/utils/profile.py
+-rw-r--r--  2.0 unx     2869 b- defN 23-Jun-21 21:07 microprobe/utils/run.py
+-rw-r--r--  2.0 unx     5319 b- defN 23-Jun-21 21:07 microprobe/utils/yaml.py
+-rw-rw-r--  2.0 unx    11356 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6545 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/RECORD
+74 files, 1165071 bytes uncompressed, 244555 bytes compressed:  79.0%
```

## zipnote {}

```diff
@@ -201,23 +201,23 @@
 
 Filename: microprobe/utils/run.py
 Comment: 
 
 Filename: microprobe/utils/yaml.py
 Comment: 
 
-Filename: microprobe_all-0.5.20220906104555.dist-info/LICENSE
+Filename: microprobe_all-0.5.20230629114852.dist-info/LICENSE
 Comment: 
 
-Filename: microprobe_all-0.5.20220906104555.dist-info/METADATA
+Filename: microprobe_all-0.5.20230629114852.dist-info/METADATA
 Comment: 
 
-Filename: microprobe_all-0.5.20220906104555.dist-info/WHEEL
+Filename: microprobe_all-0.5.20230629114852.dist-info/WHEEL
 Comment: 
 
-Filename: microprobe_all-0.5.20220906104555.dist-info/top_level.txt
+Filename: microprobe_all-0.5.20230629114852.dist-info/top_level.txt
 Comment: 
 
-Filename: microprobe_all-0.5.20220906104555.dist-info/RECORD
+Filename: microprobe_all-0.5.20230629114852.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## microprobe/code/context.py

```diff
@@ -12,24 +12,32 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.context` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, print_function, annotations
+
+# Built-in modules
+from typing import TYPE_CHECKING, Tuple, Dict, List
 
 # Third party modules
 import six
 
 # Own modules
 from microprobe.code.address import Address, InstructionAddress
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import RejectingDict, smart_copy_dict
 
+# Type hints
+if TYPE_CHECKING:
+    from microprobe.target.isa.register import Register
+    from microprobe.code.address import MemoryValue
+    from microprobe.target.isa.dat import DynamicAddressTranslation
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["Context"]
 
 # Functions
 
@@ -40,32 +48,39 @@
     on each benchmark building block)
 
 
     """
 
     def __init__(
             self,
-            default_context=None,
-            code_segment=None,
-            data_segment=None,
-            symbolic=True,
-            absolute=False
+            default_context: Context | None = None,
+            code_segment: int | None = None,
+            data_segment: int | None = None,
+            symbolic: bool = True,
+            absolute: bool = False
     ):
         """
 
         :param default_context:  (Default value = None)
         :param code_segment:  (Default value = None)
         :param data_segment:  (Default value = None)
         :param symbolic:  (Default value = True)
 
         """
 
-        self._reserved_registers = RejectingDict()
-        self._register_values = [{}, {}]
-        self._memory_values = [{}, {}]
+        self._reserved_registers: Dict[str, Register] = RejectingDict()
+
+        self._register_values: Dict[
+            Register, int | float | Address | str | None
+        ] = {}
+        self._value_registers: Dict[
+            int | float | Address | str, List[Register]
+        ] = {}
+        self._memory_values: Dict[Address, MemoryValue] = {}
+        self._value_memorys: Dict[MemoryValue, List[MemoryValue]] = {}
 
         self._data_segment = data_segment
         self._code_segment = code_segment
         self._symbolic = symbolic
         self._fabsolute = absolute
 
         self._dat = None
@@ -78,58 +93,55 @@
 
         newcontext = Context()
 
         # pylint: disable=protected-access
         newcontext._reserved_registers = smart_copy_dict(
             self._reserved_registers
         )
-        newcontext._register_values[0] = smart_copy_dict(
-            self._register_values[0]
-        )
-        newcontext._register_values[1] = smart_copy_dict(
-            self._register_values[1]
-        )
-        newcontext._memory_values[0] = smart_copy_dict(self._memory_values[0])
-        newcontext._memory_values[1] = smart_copy_dict(
-            self._register_values[1]
-        )
+        newcontext._register_values = smart_copy_dict(self._register_values)
+        newcontext._value_registers = smart_copy_dict(self._value_registers)
+        newcontext._memory_values = smart_copy_dict(self._memory_values)
+        newcontext._value_memorys = smart_copy_dict(self._value_memorys)
 
         if self._dat is not None:
             newcontext.set_dat(self._dat.copy())
 
         newcontext.set_code_segment(self.code_segment)
         newcontext.set_data_segment(self.data_segment)
         newcontext.set_symbolic(self.symbolic)
         newcontext.set_absolute(self.force_absolute)
 
         return newcontext
 
-    def add_reserved_registers(self, rregs):
+    def add_reserved_registers(self, rregs: List[Register]):
         """Add the provided registers into the reserved register list.
 
         :param rregs: Registers to reserve
         :type rregs: :class:`~.list` of :class:`~.Register`
 
         """
 
         for reg in rregs:
             self._reserved_registers[reg.name] = reg
 
-    def remove_reserved_registers(self, rregs):
+    def remove_reserved_registers(self, rregs: List[Register]):
         """Remove the provided registers from the reserved register list.
 
         :param rregs: Registers to un-reserve
         :type rregs: :class:`~.list` of :class:`~.Register`
 
         """
 
         for reg in rregs:
             del self._reserved_registers[reg.name]
 
-    def set_register_value(self, register, value):
+    def set_register_value(
+            self,
+            register: Register, value: int | float | Address | str
+    ):
         """Set the provided register to the specified value.
 
         :param register: Register to set
         :type register: :class:`~.Register`
         :param value: Value to assign
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
@@ -145,68 +157,68 @@
 
         if isinstance(value, str):
             assert len(value.split("_")) == 2
 
         if self.get_register_value(register) is not None:
             self.unset_register(register)
 
-        self._register_values[0][register] = value
+        self._register_values[register] = value
 
-        if value in self._register_values[1]:
-            if register not in self._register_values[1][value]:
-                self._register_values[1][value].append(register)
+        if value in self._value_registers:
+            if register not in self._value_registers[value]:
+                self._value_registers[value].append(register)
         else:
-            self._register_values[1][value] = [register]
+            self._value_registers[value] = [register]
 
         # assert self.get_register_value(register) == value
-        # assert value in self._register_values[1].keys()
-        # assert self._register_values[0][register] == value
+        # assert value in self._value_registers.keys()
+        # assert self._register_values[register] == value
 
-    def get_closest_value(self, value):
+    def get_closest_value(self, value: int | float | Address | str):
         """Returns the closest value to the given value.
 
         Returns the closest value to the given value. If there are
         not values registered, `None` is returned.
 
         :param value: value to look for
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
 
         """
 
-        possible_regs = []
+        possible_regs: List[Tuple[Register, int | float | Address | str]] = []
 
-        for reg, val in self._register_values[0].items():
+        for reg, val in self._register_values.items():
 
             if not isinstance(val, type(value)):
                 continue
 
             possible_regs.append((reg, val))
 
         possible_regs = sorted(possible_regs,
                                key=lambda x: abs(x[1] - value))
         if possible_regs:
             return possible_regs[0]
 
         return None
 
-    def get_closest_address_value(self, address):
+    def get_closest_address_value(self, address: Address):
         """Returns the closest address to the given address.
 
         Returns the closest address to the given address. If there are
         not addresses registered, `None` is returned.
 
         :param address: Address to look for
         :type address: :class:`~.Address`
 
         """
 
-        possible_regs = []
+        possible_regs: List[Tuple[Register, Address]] = []
 
-        for reg, value in self._register_values[0].items():
+        for reg, value in self._register_values.items():
 
             if not isinstance(value, Address):
                 continue
 
             if Address(base_address=value.base_address) == \
                     Address(base_address=address.base_address):
                 possible_regs.append((reg, value))
@@ -215,30 +227,30 @@
                                key=lambda x: abs(x[1].displacement -
                                                  address.displacement))
         if possible_regs:
             return possible_regs[0]
 
         return None
 
-    def get_register_closest_value(self, value):
+    def get_register_closest_value(self, value: int | float | str):
         """Returns the register with the closest value to the given value.
 
         Returns the register with the closest value to the given value.
         If there are not values registered, `None` is returned.
         Address values are ignored.
 
         :param value: Value to look for
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
 
         """
 
-        possible_regs = []
+        possible_regs: List[Tuple[Register, int | float | str]] = []
 
-        for reg, reg_value in self._register_values[0].items():
+        for reg, reg_value in self._register_values.items():
 
             if isinstance(value, Address):
                 continue
 
             if not isinstance(reg_value, type(value)):
                 continue
 
@@ -256,236 +268,236 @@
                                                      int(value.split("_")[0])))
 
         if possible_regs:
             return possible_regs[0]
 
         return None
 
-    def get_register_value(self, register):
+    def get_register_value(self, register: Register):
         """Returns the register value. `None` if not found.
 
         :param register: Register to get its value
         :type register: :class:`~.Register`
 
         """
 
-        value = self._register_values[0].get(register, None)
+        value = self._register_values.get(register, None)
         if value is not None:
-            assert value in self._register_values[1].keys()
+            assert value in self._value_registers.keys()
 
         return value
 
-    def get_registername_value(self, register_name):
+    def get_registername_value(self, register_name: str):
         """Returns the register value. `None` if not found.
 
         :param register: Register name to get its value
         :type register: :class:`~.str`
         :param register_name:
 
         """
         assert isinstance(register_name, str)
 
-        register_names = [reg.name for reg in self._register_values[0]]
+        register_names = [reg.name for reg in self._register_values]
         if register_name not in register_names:
             return None
 
         register = [
-            reg for reg in self._register_values[0]
+            reg for reg in self._register_values
             if reg.name == register_name
         ][0]
 
-        return self._register_values[0].get(register, None)
+        return self._register_values.get(register, None)
 
-    def unset_registers(self, registers):
+    def unset_registers(self, registers: List[Register]):
         """Removes the values from registers.
 
         :param registers: List of registers
         :type registers: :class:`~.list` of :class:`~.Register`
 
         """
         for reg in registers:
             self.unset_register(reg)
 
-    def unset_register(self, register):
+    def unset_register(self, register: Register):
         """Remove the value from a register.
 
         :param register: Registers
         :type register: :class:`~.Register`
 
         """
 
-        assert self._register_values[0][register] is not None
+        assert self._register_values[register] is not None
 
-        value = self._register_values[0][register]
-        self._register_values[1][value].remove(register)
+        value = self._register_values[register]
+        self._value_registers[value].remove(register)
 
-        if not self._register_values[1][value]:
-            del self._register_values[1][value]
+        if not self._value_registers[value]:
+            del self._value_registers[value]
 
-        self._register_values[0][register] = None
+        self._register_values[register] = None
 
-    def set_memory_value(self, mem_value):
+    def set_memory_value(self, mem_value: MemoryValue):
         """Sets a memory value.
 
         :param mem_value: Memory value to set.
         :type mem_value: :class:`~.MemoryValue`
 
         """
 
         LOG.debug("Start set memory value: %s", mem_value)
 
         self.unset_memory(mem_value.address, mem_value.length)
-        self._memory_values[0][mem_value.address] = mem_value
+        self._memory_values[mem_value.address] = mem_value
 
-        if mem_value.value in self._memory_values[0]:
+        if mem_value.value in self._memory_values:
 
-            if mem_value not in self._memory_values[1][mem_value.value]:
+            if mem_value not in self._value_memorys[mem_value.value]:
 
-                self._memory_values[1][mem_value.value].append(mem_value)
+                self._value_memorys[mem_value.value].append(mem_value)
                 LOG.debug(
                     "Values inv %s: %s", mem_value.value,
-                    self._memory_values[1][mem_value.value]
+                    self._value_memorys[mem_value.value]
                 )
 
             else:
                 LOG.debug("Already in inv dictionary")
 
         else:
 
-            self._memory_values[1][mem_value.value] = [mem_value]
+            self._value_memorys[mem_value.value] = [mem_value]
             LOG.debug("Values inv %s: %s", mem_value.value, [mem_value])
 
-        assert self._memory_values[0][mem_value.address] == mem_value
-        assert mem_value in self._memory_values[1][mem_value.value]
+        assert self._memory_values[mem_value.address] == mem_value
+        assert mem_value in self._value_memorys[mem_value.value]
 
         LOG.debug("End set memory value: %s", mem_value)
 
-    def get_memory_value(self, address):
+    def get_memory_value(self, address: Address):
         """Gets a memory value.
 
         :param address: Address to look for
         :type address: :class:`~.Address`
 
         """
 
-        if address in self._memory_values[0]:
-            return self._memory_values[0][address]
+        if address in self._memory_values:
+            return self._memory_values[address]
 
         return None
 
-    def unset_memory(self, address, length):
+    def unset_memory(self, address: Address, length: int):
         """Unsets a memory region.
 
         :param address: Start address of the region
         :type address: :class:`~.Address`
         :param length: Length in bytes of the region
         :type length: :class:`~.int`
 
         """
 
         LOG.debug("Start unset address: %s (length: %s)", address, length)
 
         possible_addresses = [
             addr
-            for addr in self._memory_values[0]
+            for addr in self._memory_values
             if addr.base_address == address.base_address
         ]
 
         # LOG.debug("Possible addresses: %s", possible_addresses)
 
         for paddr in possible_addresses:
 
             diff = paddr - address
             diff2 = address - paddr
-            length2 = self._memory_values[0][paddr].length
+            length2 = self._memory_values[paddr].length
 
             if (
                     (diff >= 0 and diff < length) or
                     (diff2 >= 0 and diff2 < length2)
             ):
 
                 LOG.debug("Address overlap: %s", paddr)
-                mem_value = self._memory_values[0].pop(paddr)
+                mem_value = self._memory_values.pop(paddr)
 
                 LOG.debug("Memory value: %s", mem_value)
 
-                if mem_value in self._memory_values[1][mem_value.value]:
-                    self._memory_values[1][mem_value.value].remove(mem_value)
+                if mem_value in self._value_memorys[mem_value.value]:
+                    self._value_memorys[mem_value.value].remove(mem_value)
 
         LOG.debug("Finish unset address: %s (length: %s)", address, length)
 
-    def register_has_value(self, value):
+    def register_has_value(self, value: int | float | Address | str):
         """Returns if a value is in a register.
 
         :param value: Value to look for
         :type value: :class:`~.bool`
 
         """
-        return value in list([elem for elem in self._register_values[1].keys()
+        return value in list([elem for elem in self._value_registers.keys()
                              if type(elem) == type(value)])
 
-    def registers_get_value(self, value):
+    def registers_get_value(self, value: int | float | Address | str):
         """Gets a list of registers containing the specified value.
 
         :param value: Value to look for
         :type value: :class:`~.int` or :class:`~.float` or :class:`~.Address`
 
         """
 
-        keyl = [key for key in self._register_values[1] if key == value]
+        keyl = [key for key in self._value_registers if key == value]
 
         if len(keyl) != 1:
             assert keyl == 1
 
-        return self._register_values[1][keyl[0]]
+        return self._value_registers[keyl[0]]
 
     @property
     def register_values(self):
         """Dictionary of register, value pairs (:class:`~.dict`)"""
-        return self._register_values[0]
+        return self._register_values
 
     @property
     def reserved_registers(self):
         """List of reserved registers (:class:`~.list`)"""
         return list(self._reserved_registers.values())
 
     @property
     def data_segment(self):
         """Address starting the data segment (::class:`~.int`)"""
         return self._data_segment
 
-    def set_data_segment(self, value):
+    def set_data_segment(self, value: int):
         """Sets the data segment start address.
 
         :param value: Start address.
         :type value: ::class:`~.int`
 
         """
         self._data_segment = value
 
     @property
     def dat(self):
         """DAT object (:class:`~.DynamicAddressTranslation`"""
         return self._dat
 
-    def set_dat(self, dat):
+    def set_dat(self, dat: DynamicAddressTranslation):
         """Sets the dynamic address translation object.
 
         :param dat: DAT object.
         :type dat: :class:`~.DynamicAddressTranslation`
 
         """
         self._dat = dat
 
     @property
     def code_segment(self):
         """Address starting the code segment (::class:`~.int`)"""
         return self._code_segment
 
-    def set_code_segment(self, value):
+    def set_code_segment(self, value: int):
         """Sets the code segment start address.
 
         :param value: Start address.
         :type value: :class:`~.int`
 
         """
         self._code_segment = value
@@ -495,15 +507,15 @@
         """Boolean indicating if the context allows symbol labels
 
         Boolean indicating if the context allows symbol labels
         (:class:`~.bool`)
         """
         return self._symbolic
 
-    def set_symbolic(self, value):
+    def set_symbolic(self, value: bool):
         """Sets the symbolic property.
 
         :param value: Boolean indicating if the context allows symbol labels
         :type value: :class:`~.bool`
 
         """
         self._symbolic = value
@@ -513,63 +525,63 @@
         """Boolean indicating if absolute addresses are needed.
 
         Boolean indicating if absolute addresses are needed
         (:class:`~.bool`)
         """
         return self._fabsolute
 
-    def set_absolute(self, value):
+    def set_absolute(self, value: bool):
         """Sets the force_absolute property.
 
         :param value: Boolean indicating if absolute addresses are needed
         :type value: :class:`~.bool`
 
         """
         self._fabsolute = value
 
     # def _validate(self):
-    #     for register in self._register_values[0]:
-    #        value = self._register_values[0][register]
+    #     for register in self._register_values:
+    #        value = self._register_values[register]
     #        if value is not None:
-    #            assert register in self._register_values[1][value]
+    #            assert register in self._value_registers[value]
 
     def dump(self):
         """Return a dump of the current context status.
 
         Return a dump of the current context status. Very useful for pass
         debugging purposes.
 
 
         """
 
-        mstr = []
+        mstr: List[str] = []
         mstr.append("-" * 80)
         mstr.append("Context status:")
         mstr.append("Reserved Registers:")
 
         for key, value in sorted(self._reserved_registers.items()):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Registers values:")
-        for key, value in sorted(self._register_values[0].items()):
+        for key, value in sorted(self._register_values.items()):
             mstr.append("Idx:\t%s\tRaw Value:\t%s" % (key, value))
 
         mstr.append("Registers values inverted:")
         for key, value in sorted([
                     (str(k), str(v)) for k, v
-                    in self._register_values[1].items()
+                    in self._value_registers.items()
                 ]):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Memory values:")
-        for key, value in sorted(self._memory_values[0].items()):
+        for key, value in sorted(self._memory_values.items()):
             mstr.append("Idx:\t%s\tRaw Value:\t%s" % (key, value))
 
         mstr.append("Memory values inverted:")
-        for key, value in sorted(self._memory_values[1].items()):
+        for key, value in sorted(self._value_memorys.items()):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Code segment: %s" % self._code_segment)
         mstr.append("Data segment: %s" % self._data_segment)
         mstr.append("Symbolic context: %s" % self._symbolic)
 
         mstr.append("-" * 80)
```

## microprobe/passes/initialization/__init__.py

```diff
@@ -466,15 +466,15 @@
 
 
 class AddInitializationInstructionsPass(microprobe.passes.Pass):
     """AddInitializationInstructionsPass pass.
 
     """
 
-    def __init__(self, instr, operands):
+    def __init__(self, instr, operands=None):
         """
 
         :param instr:
         :param operands:
 
         """
         super(AddInitializationInstructionsPass, self).__init__()
@@ -489,22 +489,26 @@
         """
 
         :param building_block:
         :param dummy_target:
 
         """
 
-        for instr, operands in zip(self._instr, self._operands):
-            newinstr = microprobe.code.ins.Instruction()
-            # print instr
-            # print self._instr
-            newinstr.set_arch_type(instr)
-            newinstr.set_operands(operands)
-            # print operands
-            building_block.add_init([newinstr])
+        if self._operands is not None:
+            for instr, operands in zip(self._instr, self._operands):
+                newinstr = microprobe.code.ins.Instruction()
+                # print instr
+                # print self._instr
+                newinstr.set_arch_type(instr)
+                newinstr.set_operands(operands)
+                # print operands
+                building_block.add_init([newinstr])
+        else:
+            for instr in self._instr:
+                building_block.add_init([instr])
 
 
 class AutoAlignPass(microprobe.passes.Pass):
     """AutoAlignPass pass.
 
     """
```

## microprobe/target/env/__init__.py

```diff
@@ -260,14 +260,39 @@
         raise NotImplementedError
 
     @abc.abstractproperty
     def target(self):
         """ """
         raise NotImplementedError
 
+    @abc.abstractmethod
+    def hook_before_test_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_after_test_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_test_init_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_after_reset_instructions(self):
+        """ """
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def hook_test_end_instructions(self):
+        """ """
+        raise NotImplementedError
+
 
 class GenericEnvironment(Environment):
     """ """
 
     _cmp_attributes = ["name", "descr"]
 
     def __init__(self, name, descr, isa, little_endian=False):
@@ -486,7 +511,27 @@
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if getattr(self, attr) >= getattr(other, attr):
                 continue
             else:
                 return False
         return True
+
+    def hook_before_test_instructions(self):
+        """ """
+        return []
+
+    def hook_after_test_instructions(self):
+        """ """
+        return [self._target.nop()]
+
+    def hook_test_init_instructions(self):
+        """ """
+        return []
+
+    def hook_after_reset_instructions(self):
+        """ """
+        return []
+
+    def hook_test_end_instructions(self):
+        """ """
+        return []
```

## Comparing `microprobe_all-0.5.20220906104555.dist-info/LICENSE` & `microprobe_all-0.5.20230629114852.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `microprobe_all-0.5.20220906104555.dist-info/METADATA` & `microprobe_all-0.5.20230629114852.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: microprobe-all
-Version: 0.5.20220906104555
+Version: 0.5.20230629114852
 Summary: Microprobe: Microbenchmark generation framework: A modular and extensible framework to generate microbenchmarks
 Home-page: https://github.com/IBM/microprobe
 Author: Ramon Bertran
 Author-email: rbertra@us.ibm.com
 Maintainer: Ramon Bertran
 Maintainer-email: rbertra@us.ibm.com
 License: Apache Version 2.0
```

## Comparing `microprobe_all-0.5.20220906104555.dist-info/RECORD` & `microprobe_all-0.5.20230629114852.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 microprobe/exceptions.py,sha256=nBz7iho1-56vWCt3RcmdB3N-VH64GtrmpffjBDtG9A0,6504
 microprobe/property.py,sha256=9QmP2rA40FOifkQ5gnFjek2xzv2Buyr5XzP884W0ELg,10213
 microprobe/code/__init__.py,sha256=w8k-i1mSqc_s2X4fIg3JnvWYBzJvgbRo4OIoRJokFn0,25912
 microprobe/code/address.py,sha256=WWjtOLHHMTIMsQzlphuZTofyg5O7zMYWGqhFB6D52BQ,14640
 microprobe/code/bbl.py,sha256=xfQ2jHY0F83ZjVw6UM2E8sOuB4k5eYImhkdYKbEFNJY,11088
 microprobe/code/benchmark.py,sha256=2U2Kj4_9M6BBPDNIf__HudTk-HgF-EK8t6LXbuFpk3Q,14023
 microprobe/code/cfg.py,sha256=1BQ3tdeVIdfZYlTbH36bC0htXAFPOuNk1phnLvpDXMI,3379
-microprobe/code/context.py,sha256=VK7v6OWt9ID87rJ1bk-k5j5tqxRNQXZigSyP9k1uiZA,17316
+microprobe/code/context.py,sha256=VKRRKnPh4z4ZTenooDlWtw9GsiS-X0446n3aDwr2-28,18207
 microprobe/code/ins.py,sha256=TaGe7uCH_y3elWX79wtjlf_jXzFE5ewQzF204MnO_Ws,74582
 microprobe/code/var.py,sha256=FcwHFccukhU_y2-AAmiUNs6Fkrd5bPANIXa7WbrVZIk,11674
 microprobe/code/wrapper.py,sha256=PQWFxnGJYeEzPpAw7_vVv3ASQ6bLcs2VTUoGHNzPHfw,5909
 microprobe/driver/__init__.py,sha256=TaAuxqdWA5dvHoznIgZJ9cLEIbvAROJZjf24MkGTv5k,671
 microprobe/driver/genetic.py,sha256=pYWkGu-dJFSMaCfnk1LWgwiRskBrWRyusk_gQ1jZC90,10949
 microprobe/driver/guided.py,sha256=z7fPulazNjeccg5AMznsogkh42xjVeyn6UcLXuSilCU,677
 microprobe/model/__init__.py,sha256=Evr_zzwoEkWCnmdgj68IRxLC8JegvB0cAYpkYxmMa6A,1642
@@ -18,25 +18,25 @@
 microprobe/passes/__init__.py,sha256=6ceMHZUDbOhR4_mSSHY43yDH6hl-pK9mTrNcnhSHX2k,2180
 microprobe/passes/address/__init__.py,sha256=AJApvRvHOchD2Fy9E5-XGHfcshFxx1ok0go8c0CBSvU,7684
 microprobe/passes/branch/__init__.py,sha256=PxQIteOsacSLIRVzIHn1W79Nb02ZLq6YlSxqRv7xY8o,58027
 microprobe/passes/dat/__init__.py,sha256=l9mEItBt58OI7tQh0CorAilF2t6J1JRvGdzS4QUpJJU,2527
 microprobe/passes/decimal/__init__.py,sha256=tXBqRpa-HSfxZi61hjWD3YaMZ4_a-AzP6BvhJtfOgRs,3028
 microprobe/passes/float/__init__.py,sha256=B3DMgvmgJOBTQX511End8QEWLvpQHO4hgDrbnWoKAQU,6533
 microprobe/passes/ilp/__init__.py,sha256=MTxI3YMsiP6QSG82iiYdP1kIGiDJ5l9nYqInFxfs_P0,3129
-microprobe/passes/initialization/__init__.py,sha256=SdW9xuanvmwUOy7YuCtOqSNuz6oxlpRBJN2lJHqYqG4,17355
+microprobe/passes/initialization/__init__.py,sha256=YQd9G0afMVBd2bvr7tzlD947Wsk0ioTTnn97bSzRPvo,17532
 microprobe/passes/instruction/__init__.py,sha256=Ddio2x6J4yxKodFwf7oTpaudB6PkO6IaR43F1z3P9kg,45784
 microprobe/passes/memory/__init__.py,sha256=GU6rav5eNi37OEsKr2NLcOj3-qxBBputCKcqWo1SECg,106225
 microprobe/passes/register/__init__.py,sha256=1rzpVnbEc5eDtzYQxeUHeOMCnNDeAIgBOx2xDKk9kZU,39864
 microprobe/passes/structure/__init__.py,sha256=s1gHg2_GumC-EsQ5BfWwXxAfgaP-ufAlMRYmpLtBbMs,7658
 microprobe/passes/switch/__init__.py,sha256=jiGdt2SYylyx2zVzkOhytLrXCfzkKtEDyvlIopHpVFA,28125
 microprobe/passes/symbol/__init__.py,sha256=PDi4DS3Vda6FoVxHnd8Nuw_HpYTJQgiud6Y3eftChzA,11544
 microprobe/passes/variable/__init__.py,sha256=e5uB6_t71B6axZ3KVcfWdg8mTOXkw7AofeTIWeXZTh4,7484
 microprobe/schemas/__init__.py,sha256=Ux-r6dlnsCasIE7luA9Fh-YCwDFwPdxVw-XC_loO1cY,710
 microprobe/target/__init__.py,sha256=dDYNhEHpA4lCvqfsxcOcL__tzXKvB0beHbEp7PsUHgY,19638
-microprobe/target/env/__init__.py,sha256=3S8M52aJUzOChXQCEoxzkak9Upjhq2-nuDG6hw_1zeE,12398
+microprobe/target/env/__init__.py,sha256=-AkeaQgcpF-9UDCJi7yRScKlRUZ_miLmfZzgvKgWLfQ,13404
 microprobe/target/isa/__init__.py,sha256=3XkrUI-O_7XattffRnGbZ6RQycLUGNydk_wk77W5zmE,26085
 microprobe/target/isa/comparator.py,sha256=v4jDBZp6oTT1cPq5r1cnbwLEtfFh5SuNa2nqDksr4OM,4486
 microprobe/target/isa/dat.py,sha256=fbkB-hSaY1TmtMmVfY7-mX8aKMhd-mbM_QaI0AwcA4o,6482
 microprobe/target/isa/generator.py,sha256=RBAfOadKX-B_W6ZxwxAxk_5puX5fu_uV6a6oOka21m8,3506
 microprobe/target/isa/instruction.py,sha256=EMBZHCzsLLDBDgVK9D8I0F9AD39TUq18N_FMH29MbIY,66656
 microprobe/target/isa/instruction_field.py,sha256=ZJXvZicyp1AoIeAjLMsMyHSq1EhCuAQ8OHnlKW7BYAU,5783
 microprobe/target/isa/instruction_format.py,sha256=gN1ib2trFjid20DAil48Wqd9cckWBQTY--olAh1U_F4,12051
@@ -63,12 +63,12 @@
 microprobe/utils/misc.py,sha256=7JOQ_OGpOvt6gGuukgNuu7q0IfxUm5WmeTirjKllohg,14194
 microprobe/utils/mpt.py,sha256=6CjAQlz8aAuemZSS7TFY0DDImwgLIscLTdSk8zQloYU,72494
 microprobe/utils/objdump.py,sha256=xkr0ZZJsRZ7kjFNUCTsq5DjjeCE5fnAN4qadYC3-Crw,11342
 microprobe/utils/policy.py,sha256=YwuOJjN6_v4dTLET691QjgHoI-GxBwpX5KxMBRmCiQU,2718
 microprobe/utils/profile.py,sha256=L3O0cEbcYUHOM9DKEulhCTmLKadhWp7CMWHMuhk2seU,1169
 microprobe/utils/run.py,sha256=ymTUlbRtXeqy8taojUaZtqXny5xcoTXx_Fn5DltTN14,2869
 microprobe/utils/yaml.py,sha256=qy4XXg0ySNZ1YanaX3a-eA41-A7IrLLP0bR4ajh0U1M,5319
-microprobe_all-0.5.20220906104555.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
-microprobe_all-0.5.20220906104555.dist-info/METADATA,sha256=aUv0vuLfF8no8O9JRF6rcO4eWcaobKXG7Axu5dmXHSw,1875
-microprobe_all-0.5.20220906104555.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
-microprobe_all-0.5.20220906104555.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
-microprobe_all-0.5.20220906104555.dist-info/RECORD,,
+microprobe_all-0.5.20230629114852.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
+microprobe_all-0.5.20230629114852.dist-info/METADATA,sha256=2m6aVksQsQPWJCZ6HyM7jXgq4-pnDcxeb29NvZUs5vI,1875
+microprobe_all-0.5.20230629114852.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+microprobe_all-0.5.20230629114852.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
+microprobe_all-0.5.20230629114852.dist-info/RECORD,,
```

