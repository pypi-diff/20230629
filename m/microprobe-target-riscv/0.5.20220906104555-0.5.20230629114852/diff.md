# Comparing `tmp/microprobe_target_riscv-0.5.20220906104555-py2.py3-none-any.whl.zip` & `tmp/microprobe_target_riscv-0.5.20230629114852-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,83 +1,92 @@
-Zip file size: 87192 bytes, number of entries: 81
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/doc/__init__.py
--rw-r--r--  2.0 unx       18 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/doc/examples.rst
--rw-r--r--  2.0 unx      173 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/doc/examples_riscv.rst
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/env/__init__.py
--rw-r--r--  2.0 unx     3660 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/env/riscv_linux_gcc.py
--rw-r--r--  2.0 unx     3115 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/env/riscv_test_p.py
--rw-r--r--  2.0 unx      505 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/Makefile.in
--rw-r--r--  2.0 unx      160 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/Makefrag
--rw-r--r--  2.0 unx     6417 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/README.md
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/__init__.py
--rw-r--r--  2.0 unx      594 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/configure.ac
--rw-r--r--  2.0 unx    12209 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/riscv_branch.py
--rw-r--r--  2.0 unx     5870 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/riscv_ipc.py
--rw-r--r--  2.0 unx     5741 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/riscv_ipc_c.py
--rw-r--r--  2.0 unx     8886 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/riscv_ipc_seq.py
--rw-r--r--  2.0 unx      694 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/riscv_ipc/Makefile
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/examples/riscv_ipc/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/__init__.py
--rw-r--r--  2.0 unx      635 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/comparator.py
--rw-r--r--  2.0 unx      635 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/generator.py
--rw-r--r--  2.0 unx     1130 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/getcontext.S
--rw-r--r--  2.0 unx    14006 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction.py
--rw-r--r--  2.0 unx    68224 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction.yaml
--rw-r--r--  2.0 unx      891 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_field.py
--rw-r--r--  2.0 unx     8059 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_field.yaml
--rw-r--r--  2.0 unx      896 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_format.py
--rw-r--r--  2.0 unx     8377 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_format.yaml
--rw-r--r--  2.0 unx    27197 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/isa.py
--rw-r--r--  2.0 unx     1288 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/isa.yaml
--rw-r--r--  2.0 unx      635 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/operand.py
--rw-r--r--  2.0 unx     9936 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/operand.yaml
--rw-r--r--  2.0 unx      862 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/register.py
--rw-r--r--  2.0 unx      950 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/register.yaml
--rw-r--r--  2.0 unx      884 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/register_type.py
--rw-r--r--  2.0 unx      846 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/register_type.yaml
--rw-r--r--  2.0 unx     1130 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/setcontext.S
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/__init__.py
--rw-r--r--  2.0 unx      944 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch.yaml
--rw-r--r--  2.0 unx      859 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch_conditional.yaml
--rw-r--r--  2.0 unx      906 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch_relative.yaml
--rw-r--r--  2.0 unx      704 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/decimal.yaml
--rw-r--r--  2.0 unx      835 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/disable_asm.yaml
--rw-r--r--  2.0 unx     1891 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/memory.yaml
--rw-r--r--  2.0 unx      768 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/memory_with_update.yaml
--rw-r--r--  2.0 unx      688 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/priviledged.yaml
--rw-r--r--  2.0 unx      800 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/switching.yaml
--rw-r--r--  2.0 unx      689 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-common/instruction_props/unsupported.yaml
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-v2_2/__init__.py
--rw-r--r--  2.0 unx      581 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-v2_2/instruction.yaml
--rw-r--r--  2.0 unx      686 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/isa/riscv-v2_2/isa.yaml
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/policies/__init__.py
--rw-r--r--  2.0 unx     5081 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/policies/epi.py
--rw-r--r--  2.0 unx     5798 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/policies/seq.py
--rw-r--r--  2.0 unx     7078 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/policies/seqtune.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/templates/__init__.py
--rw-r--r--  2.0 unx     9157 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/templates/riscv.ldscript
--rw-r--r--  2.0 unx     9157 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_linux_gcc.ldscript
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/__init__.py
--rw-r--r--  2.0 unx      857 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element.py
--rw-r--r--  2.0 unx      666 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element.yaml
--rw-r--r--  2.0 unx      880 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type.py
--rw-r--r--  2.0 unx      968 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type.yaml
--rw-r--r--  2.0 unx      834 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/microarchitecture.py
--rw-r--r--  2.0 unx      969 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/microarchitecture.yaml
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/__init__.py
--rw-r--r--  2.0 unx     1090 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/cache_hierarchy.yaml
--rw-r--r--  2.0 unx      730 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/cache_level.yaml
--rw-r--r--  2.0 unx      718 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/data_cache.yaml
--rw-r--r--  2.0 unx      732 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/instruction_cache.yaml
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-generic/__init__.py
--rw-r--r--  2.0 unx      671 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/uarch/riscv-generic/microarchitecture.yaml
--rw-r--r--  2.0 unx        0 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/wrappers/__init__.py
--rw-r--r--  2.0 unx     3035 b- defN 22-Sep-06 14:46 microprobe/definitions/riscv/wrappers/riscv-tests.py
--rw-rw-r--  2.0 unx    11356 b- defN 22-Sep-06 14:46 microprobe_target_riscv-0.5.20220906104555.dist-info/LICENSE
--rw-r--r--  2.0 unx     1718 b- defN 22-Sep-06 14:46 microprobe_target_riscv-0.5.20220906104555.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 22-Sep-06 14:46 microprobe_target_riscv-0.5.20220906104555.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 22-Sep-06 14:46 microprobe_target_riscv-0.5.20220906104555.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     9421 b- defN 22-Sep-06 14:46 microprobe_target_riscv-0.5.20220906104555.dist-info/RECORD
-81 files, 276011 bytes uncompressed, 71132 bytes compressed:  74.2%
+Zip file size: 98282 bytes, number of entries: 90
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/doc/__init__.py
+-rw-r--r--  2.0 unx       18 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/doc/examples.rst
+-rw-r--r--  2.0 unx      173 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/doc/examples_riscv.rst
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/__init__.py
+-rw-r--r--  2.0 unx    14456 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/riscv_eprocessor_sim.py
+-rw-r--r--  2.0 unx     3660 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/riscv_linux_gcc.py
+-rw-r--r--  2.0 unx    10005 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/riscv_riscy_sim.py
+-rw-r--r--  2.0 unx     9977 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/riscv_sargantana_sim.py
+-rw-r--r--  2.0 unx     8530 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/riscv_spike_sim.py
+-rw-r--r--  2.0 unx     3115 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/env/riscv_test_p.py
+-rw-r--r--  2.0 unx      505 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/Makefile.in
+-rw-r--r--  2.0 unx      160 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/Makefrag
+-rw-r--r--  2.0 unx     6417 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/README.md
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/__init__.py
+-rw-r--r--  2.0 unx      594 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/configure.ac
+-rw-r--r--  2.0 unx    12209 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/riscv_branch.py
+-rw-r--r--  2.0 unx     5870 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/riscv_ipc.py
+-rw-r--r--  2.0 unx     5741 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/riscv_ipc_c.py
+-rw-r--r--  2.0 unx     8886 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/riscv_ipc_seq.py
+-rw-r--r--  2.0 unx      694 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/riscv_ipc/Makefile
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/examples/riscv_ipc/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/__init__.py
+-rw-r--r--  2.0 unx      635 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/comparator.py
+-rw-r--r--  2.0 unx      635 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/generator.py
+-rw-r--r--  2.0 unx     1130 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/getcontext.S
+-rw-r--r--  2.0 unx    14006 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction.py
+-rw-r--r--  2.0 unx    68454 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction.yaml
+-rw-r--r--  2.0 unx      891 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_field.py
+-rw-r--r--  2.0 unx     8157 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_field.yaml
+-rw-r--r--  2.0 unx      896 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_format.py
+-rw-r--r--  2.0 unx     8483 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_format.yaml
+-rw-r--r--  2.0 unx    26701 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/isa.py
+-rw-r--r--  2.0 unx     1288 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/isa.yaml
+-rw-r--r--  2.0 unx      635 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/operand.py
+-rw-r--r--  2.0 unx    10014 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/operand.yaml
+-rw-r--r--  2.0 unx      862 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/register.py
+-rw-r--r--  2.0 unx      950 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/register.yaml
+-rw-r--r--  2.0 unx      884 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/register_type.py
+-rw-r--r--  2.0 unx      846 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/register_type.yaml
+-rw-r--r--  2.0 unx     1130 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/setcontext.S
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/__init__.py
+-rw-r--r--  2.0 unx      944 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch.yaml
+-rw-r--r--  2.0 unx      859 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch_conditional.yaml
+-rw-r--r--  2.0 unx      906 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch_relative.yaml
+-rw-r--r--  2.0 unx      704 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/decimal.yaml
+-rw-r--r--  2.0 unx      835 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/disable_asm.yaml
+-rw-r--r--  2.0 unx     1891 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/memory.yaml
+-rw-r--r--  2.0 unx      768 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/memory_with_update.yaml
+-rw-r--r--  2.0 unx      688 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/priviledged.yaml
+-rw-r--r--  2.0 unx      800 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/switching.yaml
+-rw-r--r--  2.0 unx      689 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-common/instruction_props/unsupported.yaml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-v2_2/__init__.py
+-rw-r--r--  2.0 unx      581 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-v2_2/instruction.yaml
+-rw-r--r--  2.0 unx      686 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/isa/riscv-v2_2/isa.yaml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/policies/__init__.py
+-rw-r--r--  2.0 unx     5081 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/policies/epi.py
+-rw-r--r--  2.0 unx     5798 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/policies/seq.py
+-rw-r--r--  2.0 unx     7078 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/policies/seqtune.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/__init__.py
+-rw-r--r--  2.0 unx     9159 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv.ldscript
+-rw-r--r--  2.0 unx       13 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_eprocessor_sim.ldscript
+-rw-r--r--  2.0 unx     9159 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_linux_gcc.ldscript
+-rw-r--r--  2.0 unx       13 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_riscy_sim.ldscript
+-rw-r--r--  2.0 unx       13 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_sargantana_sim.ldscript
+-rw-r--r--  2.0 unx      111 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_spike_sim.ldscript
+-rw-r--r--  2.0 unx      202 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_spike_sim_routines.s
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/__init__.py
+-rw-r--r--  2.0 unx      857 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element.py
+-rw-r--r--  2.0 unx      666 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element.yaml
+-rw-r--r--  2.0 unx      880 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type.py
+-rw-r--r--  2.0 unx      968 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type.yaml
+-rw-r--r--  2.0 unx      834 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/microarchitecture.py
+-rw-r--r--  2.0 unx      969 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/microarchitecture.yaml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/__init__.py
+-rw-r--r--  2.0 unx     1090 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/cache_hierarchy.yaml
+-rw-r--r--  2.0 unx      730 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/cache_level.yaml
+-rw-r--r--  2.0 unx      718 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/data_cache.yaml
+-rw-r--r--  2.0 unx      732 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/instruction_cache.yaml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-generic/__init__.py
+-rw-r--r--  2.0 unx      671 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/uarch/riscv-generic/microarchitecture.yaml
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/wrappers/__init__.py
+-rw-r--r--  2.0 unx     3035 b- defN 23-Jun-29 15:48 microprobe/definitions/riscv/wrappers/riscv-tests.py
+-rw-rw-r--  2.0 unx    11356 b- defN 23-Jun-29 15:48 microprobe_target_riscv-0.5.20230629114852.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1718 b- defN 23-Jun-29 15:48 microprobe_target_riscv-0.5.20230629114852.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jun-29 15:48 microprobe_target_riscv-0.5.20230629114852.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Jun-29 15:48 microprobe_target_riscv-0.5.20230629114852.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    10600 b- defN 23-Jun-29 15:48 microprobe_target_riscv-0.5.20230629114852.dist-info/RECORD
+90 files, 320530 bytes uncompressed, 80196 bytes compressed:  75.0%
```

## zipnote {}

```diff
@@ -9,17 +9,29 @@
 
 Filename: microprobe/definitions/riscv/doc/examples_riscv.rst
 Comment: 
 
 Filename: microprobe/definitions/riscv/env/__init__.py
 Comment: 
 
+Filename: microprobe/definitions/riscv/env/riscv_eprocessor_sim.py
+Comment: 
+
 Filename: microprobe/definitions/riscv/env/riscv_linux_gcc.py
 Comment: 
 
+Filename: microprobe/definitions/riscv/env/riscv_riscy_sim.py
+Comment: 
+
+Filename: microprobe/definitions/riscv/env/riscv_sargantana_sim.py
+Comment: 
+
+Filename: microprobe/definitions/riscv/env/riscv_spike_sim.py
+Comment: 
+
 Filename: microprobe/definitions/riscv/env/riscv_test_p.py
 Comment: 
 
 Filename: microprobe/definitions/riscv/examples/Makefile.in
 Comment: 
 
 Filename: microprobe/definitions/riscv/examples/Makefrag
@@ -168,17 +180,32 @@
 
 Filename: microprobe/definitions/riscv/templates/__init__.py
 Comment: 
 
 Filename: microprobe/definitions/riscv/templates/riscv.ldscript
 Comment: 
 
+Filename: microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_eprocessor_sim.ldscript
+Comment: 
+
 Filename: microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_linux_gcc.ldscript
 Comment: 
 
+Filename: microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_riscy_sim.ldscript
+Comment: 
+
+Filename: microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_sargantana_sim.ldscript
+Comment: 
+
+Filename: microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_spike_sim.ldscript
+Comment: 
+
+Filename: microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_spike_sim_routines.s
+Comment: 
+
 Filename: microprobe/definitions/riscv/uarch/__init__.py
 Comment: 
 
 Filename: microprobe/definitions/riscv/uarch/riscv-common/__init__.py
 Comment: 
 
 Filename: microprobe/definitions/riscv/uarch/riscv-common/element.py
@@ -222,23 +249,23 @@
 
 Filename: microprobe/definitions/riscv/wrappers/__init__.py
 Comment: 
 
 Filename: microprobe/definitions/riscv/wrappers/riscv-tests.py
 Comment: 
 
-Filename: microprobe_target_riscv-0.5.20220906104555.dist-info/LICENSE
+Filename: microprobe_target_riscv-0.5.20230629114852.dist-info/LICENSE
 Comment: 
 
-Filename: microprobe_target_riscv-0.5.20220906104555.dist-info/METADATA
+Filename: microprobe_target_riscv-0.5.20230629114852.dist-info/METADATA
 Comment: 
 
-Filename: microprobe_target_riscv-0.5.20220906104555.dist-info/WHEEL
+Filename: microprobe_target_riscv-0.5.20230629114852.dist-info/WHEEL
 Comment: 
 
-Filename: microprobe_target_riscv-0.5.20220906104555.dist-info/top_level.txt
+Filename: microprobe_target_riscv-0.5.20230629114852.dist-info/top_level.txt
 Comment: 
 
-Filename: microprobe_target_riscv-0.5.20220906104555.dist-info/RECORD
+Filename: microprobe_target_riscv-0.5.20230629114852.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## microprobe/definitions/riscv/isa/riscv-common/instruction.yaml

```diff
@@ -2062,7 +2062,19 @@
     funct25: ['0', 'funct25', '?']
 - Name: "EBREAK_V0"
   Mnemonic: "EBREAK"
   Opcode: "73"
   Format: "sys"
   Operands:
     funct25: ['8192', 'funct25', '?']
+- Name: "CSRRS_V0"
+  Mnemonic: "CSRRS"
+  Opcode: "73"
+  Format: "csr"
+  Operands:
+    funct3: ['2', 'funct3', '?']
+- Name: "CSRRW_V0"
+  Mnemonic: "CSRRW"
+  Opcode: "73"
+  Format: "csr"
+  Operands:
+    funct3: ['1', 'funct3', '?']
```

## microprobe/definitions/riscv/isa/riscv-common/instruction_field.yaml

```diff
@@ -91,14 +91,20 @@
   Operand: "imm25"
 - Name: "i_imm12"
   Size: 12
   Description: "i_imm12"
   Show: True
   IO: "I"
   Operand: "s.imm12"
+- Name: "u_imm12"
+  Size: 12
+  Description: "u_imm12"
+  Show: True
+  IO: "I"
+  Operand: "u.imm12"
 - Name: "i_imm6"
   Size: 6
   Description: "i_imm6"
   Show: False
   IO: "?"
   Operand: "s.imm6"
 - Name: "i_imm7"
```

## microprobe/definitions/riscv/isa/riscv-common/instruction_format.yaml

```diff
@@ -594,7 +594,15 @@
   - opcode_compressed
   Assembly: OPC c_imm11
 - Name: "sys"
   Fields:
   - funct25
   - opcode
   Assembly: OPC
+- Name: "csr"
+  Fields:
+  - u_imm12
+  - rs1
+  - funct3
+  - rd
+  - opcode
+  Assembly: OPC rd, u_imm12, rs1
```

## microprobe/definitions/riscv/isa/riscv-common/isa.py

```diff
@@ -12,59 +12,83 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """
 Docstring
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import os
+from typing import TYPE_CHECKING, Dict, List
 
 # This party modules
 import six
 
 # Own modules
 from microprobe.code.address import Address, InstructionAddress
 from microprobe.code.ins import Instruction
 from microprobe.code.var import Variable, VariableArray
 from microprobe.target.isa import GenericISA
 from microprobe.utils.logger import get_logger
-from microprobe.utils.misc import twocs_to_int, int_to_twocs
+from microprobe.utils.misc import int_to_twocs, twocs_to_int
 from microprobe.exceptions import MicroprobeCodeGenerationError
 
+# Type hints
+if TYPE_CHECKING:
+    from microprobe.code.context import Context
+    from microprobe.target import Target
+    from microprobe.target.isa.instruction import InstructionType
+    from microprobe.target.isa.register import Register
+
 # Constants
 LOG = get_logger(__name__)
 _MODULE_DIR = os.path.dirname(os.path.abspath(__file__))
 _RISCV_PCREL_LABEL = 0
 
 # Functions
 
 
 # Classes
 class RISCVISA(GenericISA):
+    def __init__(
+        self,
+        name: str,
+        descr: str,
+        path: str,
+        ins: Dict[str, InstructionType],
+        regs: Dict[str, Register],
+        comparators,
+        generators,
+    ):
+        super(RISCVISA, self).__init__(
+            name, descr, path, ins, regs, comparators, generators
+        )
+        self._scratch_registers += [
+            self.registers["X31"],
+            self.registers["F7"],
+        ]
+        self._control_registers += [
+            reg for reg in self.registers.values() if reg.type.name == "rm"
+        ]
+        self._control_registers += [
+            reg for reg in self.registers.values() if reg.type.name == "SPR"
+        ]
 
-    def __init__(self, name, descr, path, ins, regs, comparators, generators):
-        super(RISCVISA, self).__init__(name, descr, path, ins, regs,
-                                       comparators,
-                                       generators)
-        self._scratch_registers += [self.registers["X31"],
-                                    self.registers["F7"]]
-        self._control_registers += [reg for reg in self.registers.values()
-                                    if reg.type.name == "rm"]
-        self._control_registers += [reg for reg in self.registers.values()
-                                    if reg.type.name == "SPR"]
-
-    def set_register(self, register, value, context, opt=False):
-
-        LOG.debug("Setting register: %s to value %d",
-                  register.name, value)
+    def set_register(
+        self,
+        register: Register,
+        value: int,
+        context: Context,
+        opt: bool = False,
+    ):
+        LOG.debug("Setting register: %s to value %d", register.name, value)
 
-        instrs = []
+        instrs: List[Instruction] = []
 
         current_value = context.get_register_value(register)
         closest_value = context.get_closest_value(value)
 
         if value == 0:
             present_reg = self.registers["X0"]
 
@@ -77,311 +101,203 @@
             if present_reg.type.name != register.type.name:
                 present_reg = None
 
         else:
             present_reg = None
 
         if register.type.name == "freg":
-
             LOG.debug("FP register")
 
             if present_reg is not None:
-
                 LOG.debug("Value already present")
 
                 instr = self.new_instruction("FSGNJ.S_V0")
                 instr.set_operands([register, present_reg, present_reg])
                 instrs.append(instr)
 
             else:
+                LOG.debug(
+                    "Setting value to scratch and " "then move to FP register"
+                )
 
-                LOG.debug("Setting value to scratch and "
-                          "then move to FP register")
-
-                instrs += self.set_register(self._scratch_registers[0], value,
-                                            context)
+                instrs += self.set_register(
+                    self._scratch_registers[0], value, context
+                )
 
                 instr = self.new_instruction("FMV.D.X_V0")
                 instr.set_operands([self._scratch_registers[0], register])
                 instrs.append(instr)
 
         elif register.type.name == "ireg":
-
             LOG.debug("Integer register")
 
             if value == 0:
-
                 LOG.debug("Zero value")
 
                 addi = self.new_instruction("ADDI_V0")
                 addi.set_operands([0, self.registers["X0"], register])
                 instrs.append(addi)
 
             elif present_reg is not None:
-
                 LOG.debug("Value already present")
 
                 addi = self.new_instruction("ADDI_V0")
                 addi.set_operands([0, present_reg, register])
                 instrs.append(addi)
 
-            elif (closest_value is not None and
-                  abs(value - closest_value[1]) < (2 ** 12)):
+            elif (
+                current_value is not None
+                and not isinstance(current_value, Address)
+                and abs(value - current_value) < (2**11)
+            ):
+                addi = self.new_instruction("ADDI_V0")
+                addi.set_operands([value - current_value, register, register])
+                instrs.append(addi)
 
+            elif (
+                closest_value is not None
+                and closest_value[0].type.name == "ireg"
+                and abs(value - closest_value[1]) < (2**11)
+            ):
                 addi = self.new_instruction("ADDI_V0")
                 addi.set_operands(
                     [value - closest_value[1], closest_value[0], register]
                 )
                 instrs.append(addi)
 
+            elif value >= -(2**31) and value < (2**31):
+                LOG.debug("Short path")
+
+                lui_val = (value >> 12) & 0xFFFFF
+                addi_val = value & 0xFFF
+
+                if addi_val >= 2048:
+                    lui_val = (lui_val + 1) & 0xFFFFF
+                    addi_val -= 4096
+
+                lui = self.new_instruction("LUI_V0")
+                lui.set_operands([lui_val, register])
+                instrs.append(lui)
+
+                addi = self.new_instruction("ADDI_V0")
+                addi.set_operands([addi_val, register, register])
+                instrs.append(addi)
+
             else:
+                LOG.debug("Long path")
+
+                lui_val = (value >> 44) & 0xFFFFF
+                addi_val = (value >> 32) & 0xFFF
 
-                if value <= 0:
-                    value = int_to_twocs(value, 64)
+                if addi_val >= 2048:
+                    lui_val = (lui_val + 1) & 0xFFFFF
+                    addi_val -= 4096
+
+                lui = self.new_instruction("LUI_V0")
+                lui.set_operands([int(lui_val), register])
+                instrs.append(lui)
 
-                register = self._scratch_registers[0]
+                addi = self.new_instruction("ADDI_V0")
+                addi.set_operands([int(addi_val), register, register])
+                instrs.append(addi)
 
-                value_highest = int((value & 0xFFFFF00000000000) >> 44)
-                value_high = int((value & 0x00000FFF00000000) >> 32)
-                value_low = int((value & 0x00000000FFFFF000) >> 12)
-                value_lowest = int((value & 0x0000000000000FFF))
-
-                if register == self._scratch_registers[0] and \
-                   (value_highest != 0 or value_high != 0):
-
-                    binstr = "{0:>064b}".format(value)
-                    size = 11
-
-                    sidx = binstr.find('1')
-                    fidx = min(sidx+size, 64)
-
-                    val = int(binstr[sidx:fidx], 2)
-                    if val != 0:
-                        addi = self.new_instruction("ADDI_V0")
-                        addi.set_operands(
-                            [val, self.registers["X0"], register]
-                        )
-                        instrs.append(addi)
-
-                    sidx2 = binstr.find('1', fidx)
-                    fidx2 = min(sidx2+size, 64)
-
-                    tshift = fidx2
-
-                    while fidx2-fidx > 0:
-                        slli = self.new_instruction("SLLI_V0")
-                        slli.set_operands([fidx2-fidx, register, register])
-                        instrs.append(slli)
-
-                        tshift = fidx2-fidx - tshift
-
-                        val = int(binstr[sidx2:fidx2], 2)
-                        if val != 0:
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands([val, register, register])
-                            instrs.append(addi)
-
-                        sidx = sidx2
-                        fidx = fidx2
-                        sidx2 = binstr.find('1', fidx)
-                        fidx2 = min(sidx2+size, 64)
-
-                    if fidx < 64:
-                        slli = self.new_instruction("SLLI_V0")
-                        slli.set_operands([64-fidx, register, register])
-                        instrs.append(slli)
+                instr = self.new_instruction("SLLI_V0")
+                instr.set_operands([11, register, register])
+                instrs.append(instr)
 
-                    LOG.debug(
-                        "Register: %s set to value %d", register.name, value
-                    )
+                instr = self.new_instruction("ORI_V0")
+                instr.set_operands(
+                    [int((value >> 21) & 0x7FF), register, register]
+                )
+                instrs.append(instr)
 
-                    return instrs
+                instr = self.new_instruction("SLLI_V0")
+                instr.set_operands([11, register, register])
+                instrs.append(instr)
 
-                if value_highest != 0:
-                    lui = self.new_instruction("LUI_V0")
-                    lui.set_operands([value_highest, register])
-                    instrs.append(lui)
-
-                if value_highest == 0 and value_high != 0:
-                    if value_high > 2047:
-                        addi = self.new_instruction("ADDI_V0")
-                        addi.set_operands(
-                            [2047, self.registers["X0"], register]
-                        )
-                        instrs.append(addi)
-                        cvalue = value_high
-                        while (cvalue > 2047):
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands([2047, register, register])
-                            instrs.append(addi)
-                            cvalue = cvalue - 2047
-                        addi = self.new_instruction("ADDI_V0")
-                        addi.set_operands([cvalue, register, register])
-                        instrs.append(addi)
-                    else:
-                        addi = self.new_instruction("ADDI_V0")
-                        addi.set_operands(
-                            [value_high, self.registers["X0"], register]
-                        )
-                        instrs.append(addi)
-
-                elif value_highest != 0 and value_high != 0:
-                    if value_high > 2047:
-                        cvalue = value_high
-                        while (cvalue > 2047):
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands([2047, register, register])
-                            instrs.append(addi)
-                            cvalue = cvalue - 2047
-                        addi = self.new_instruction("ADDI_V0")
-                        addi.set_operands([cvalue, register, register])
-                        instrs.append(addi)
-                    else:
-                        addi = self.new_instruction("ADDI_V0")
-                        addi.set_operands([value_high, register, register])
-                        instrs.append(addi)
-
-                if value_highest != 0 or value_high != 0:
-                    slli = self.new_instruction("SLLI_V0")
-                    slli.set_operands([32, register, register])
-                    instrs.append(slli)
-
-                if value_highest == 0 or value_high == 0:
-
-                    if value_low != 0:
-                        lui = self.new_instruction("LUI_V0")
-                        lui.set_operands([value_low, register])
-                        instrs.append(lui)
-
-                    if value_low == 0 and value_lowest != 0:
-                        if value_lowest > 2047:
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands(
-                                [2047, self.registers["X0"], register]
-                            )
-                            instrs.append(addi)
-                            cvalue = value_lowest
-                            while (cvalue > 2047):
-                                addi = self.new_instruction("ADDI_V0")
-                                addi.set_operands([2047, register, register])
-                                instrs.append(addi)
-                                cvalue = cvalue - 2047
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands([cvalue, register, register])
-                            instrs.append(addi)
-                        else:
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands(
-                                [value_lowest, self.registers["X0"], register]
-                            )
-                            instrs.append(addi)
-                    elif value_low != 0 and value_lowest != 0:
-                        if value_lowest > 2047:
-                            cvalue = value_lowest
-                            while (cvalue > 2047):
-                                addi = self.new_instruction("ADDI_V0")
-                                addi.set_operands([2047, register, register])
-                                instrs.append(addi)
-                                cvalue = cvalue - 2047
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands([cvalue, register, register])
-                            instrs.append(addi)
-                        else:
-                            addi = self.new_instruction("ADDI_V0")
-                            addi.set_operands(
-                                [value_lowest, register, register]
-                            )
-                            instrs.append(addi)
-                else:
-                    instrs.extend(
-                        self.set_register(
-                            self._scratch_registers[0],
-                            (value & 0x00000000FFFFFFFF),
-                            context
-                        )
-                    )
-                    add_inst = self.new_instruction("ADD_V0")
-                    add_inst.set_operands(
-                        [register, self._scratch_registers[0], register])
-                    instrs.append(add_inst)
+                instr = self.new_instruction("ORI_V0")
+                instr.set_operands(
+                    [int((value >> 10) & 0x7FF), register, register]
+                )
+                instrs.append(instr)
 
-                LOG.debug("Register: %s set to value %d",
-                          register.name, value)
+                instr = self.new_instruction("SLLI_V0")
+                instr.set_operands([10, register, register])
+                instrs.append(instr)
+
+                instr = self.new_instruction("ORI_V0")
+                instr.set_operands([int(value & 0x3FF), register, register])
+                instrs.append(instr)
 
         else:
-            LOG.debug("Register: %s set to value %d",
-                      register.name, value)
+            LOG.debug("Register: %s set to value %d", register.name, value)
             raise NotImplementedError
 
         if len(instrs) > 0:
             return instrs
 
         return super(RISCVISA, self).set_register(register, value, context)
 
-    def set_register_to_address(self,
-                                register,
-                                address,
-                                context,
-                                force_absolute=False,
-                                force_relative=False
-                                ):
-
-        instrs = []
+    def set_register_to_address(
+        self,
+        register: Register,
+        address: Address,
+        context: Context,
+        force_absolute: bool = False,
+        force_relative: bool = False,
+    ):
+        instrs: List[Instruction] = []
 
         LOG.debug("Begin setting '%s' to address '%s'", register, address)
 
         option_displacement = None
         option_label = None
 
         if isinstance(address.base_address, Variable):
-
             LOG.debug("Base address is a Variable: %s", address.base_address)
             closest = context.get_closest_address_value(address)
 
             if context.register_has_value(address):
-
                 present_reg = context.registers_get_value(address)[0]
                 displacement = 0
                 LOG.debug("Address already in register '%s'", present_reg)
 
             elif closest is not None:
-
                 present_reg, taddress = closest
                 displacement = address.displacement - taddress.displacement
-                LOG.debug("Closest value '%s' found in '%s'",
-                          taddress,
-                          present_reg)
+                LOG.debug(
+                    "Closest value '%s' found in '%s'", taddress, present_reg
+                )
                 LOG.debug("Displacement needed: %s", displacement)
 
             elif context.register_has_value(
-                    Address(base_address=address.base_address)):
-
+                Address(base_address=address.base_address)
+            ):
                 present_reg = context.registers_get_value(
-                    Address(base_address=address.base_address))[0]
+                    Address(base_address=address.base_address)
+                )[0]
                 displacement = address.displacement
-                LOG.debug("Base address '%s' found in '%s'",
-                          taddress,
-                          present_reg)
+                LOG.debug(
+                    "Base address '%s' found in '%s'", taddress, present_reg
+                )
                 LOG.debug("Displacement needed: %s", displacement)
 
             else:
-
                 present_reg = None
                 displacement = None
 
             LOG.debug("Present_reg: %s", present_reg)
             LOG.debug("Displacement: %s", displacement)
 
             if present_reg is not None:
-
-                if displacement != 0 and abs(displacement) < (2 ** 11):
-
+                if displacement != 0 and abs(displacement) < (2**11):
                     addi_ins = self.new_instruction("ADDI_V0")
-                    addi_ins.set_operands([displacement, present_reg,
-                                           register])
+                    addi_ins.set_operands(
+                        [displacement, present_reg, register]
+                    )
                     instrs.append(addi_ins)
 
                     LOG.debug("Computing directly from context (short)")
 
                     option_displacement = instrs
                     instrs = []
 
@@ -395,15 +311,14 @@
 
                 LOG.debug("Computing directly from context (long)")
                 if option_displacement is None:
                     option_displacement = instrs
                     instrs = []
 
         if context.symbolic and not force_absolute and not force_relative:
-
             instrs = []
 
             # TODO: This should be a call to the environment object because
             # the implementation depends on the environment
 
             # Base address can be an instruction label (str) or
             # a Variable instance
@@ -419,29 +334,25 @@
             global _RISCV_PCREL_LABEL
             _RISCV_PCREL_LABEL += 1
             lnum = _RISCV_PCREL_LABEL
 
             auipc_ins = self.new_instruction("AUIPC_V0")
             auipc_ins.operands()[1].set_value(register)
             auipc_ins.operands()[0].set_value(
-                "%%pcrel_hi(%s)" % basename + basedisp,
-                check=False
-            )
-            auipc_ins.set_label(
-                "%s_pcrel_%d" % (basename, lnum)
+                "%%pcrel_hi(%s)" % basename + basedisp, check=False
             )
+            auipc_ins.set_label("%s_pcrel_%d" % (basename, lnum))
 
             instrs.append(auipc_ins)
 
             addi_ins = self.new_instruction("ADDI_V0")
             addi_ins.operands()[1].set_value(register)
             addi_ins.operands()[2].set_value(register)
             addi_ins.operands()[0].set_value(
-                "%%pcrel_lo(%s_pcrel_%d)" % (basename, lnum),
-                check=False
+                "%%pcrel_lo(%s_pcrel_%d)" % (basename, lnum), check=False
             )
             instrs.append(addi_ins)
 
             # if address.displacement != 0:
             #     instrs += self.add_to_register(register,
             #     address.displacement)
 
@@ -456,70 +367,98 @@
         elif option_displacement is None:
             return option_label
         if len(option_label) <= len(option_displacement):
             return option_label
         else:
             return option_displacement
 
-    def load(self, register, address, context):
-
+    def load(self, register: Register, address: Address, context: Context):
         ldi = self.new_instruction("LD_V0")
         ldi.operands()[2].set_value(register)
         ldi.memory_operands()[0].set_address(address, context)
         return [ldi]
 
-    def load_float(self, register, address, context):
-
+    def load_float(
+        self, register: Register, address: Address, context: Context
+    ):
         ldi = self.new_instruction("FLD_V0")
         ldi.operands()[2].set_value(register)
         ldi.memory_operands()[0].set_address(address, context)
         return [ldi]
 
-    def store_float(self, register, address, context):
-
+    def store_float(
+        self, register: Register, address: Address, context: Context
+    ):
         std = self.new_instruction("FSD_V0")
         std.operands()[2].set_value(register)
         std.memory_operands()[0].set_address(address, context)
         return [std]
 
-    def store_integer(self, register, address, length, context):
-
+    def store_integer(
+        self,
+        register: Register,
+        address: Address,
+        length: int,
+        context: Context,
+    ):
         if length == 64:
             stg = self.new_instruction("SD_V0")
-            stg.operands()[2].set_value(register)
+            stg.operands()[1].set_value(register)
+            stg.operands()[3].set_value(0)
             stg.memory_operands()[0].set_address(address, context)
             return [stg]
         elif length == 32:
             stg = self.new_instruction("SW_V0")
-            stg.operands()[2].set_value(register)
+            stg.operands()[1].set_value(register)
+            stg.operands()[3].set_value(0)
+            stg.memory_operands()[0].set_address(address, context)
+            return [stg]
+        elif length == 16:
+            stg = self.new_instruction("SH_V0")
+            stg.operands()[1].set_value(register)
+            stg.operands()[3].set_value(0)
+            stg.memory_operands()[0].set_address(address, context)
+            return [stg]
+        elif length == 8:
+            stg = self.new_instruction("SB_V0")
+            stg.operands()[1].set_value(register)
+            stg.operands()[3].set_value(0)
             stg.memory_operands()[0].set_address(address, context)
             return [stg]
         else:
             raise NotImplementedError
 
-    def set_register_bits(self, dummy_register, dummy_value, dummy_mask,
-                          dummy_shift, dummy_context):
-
+    def set_register_bits(
+        self,
+        dummy_register: Register,
+        dummy_value: int,
+        dummy_mask: int,
+        dummy_shift: int,
+        dummy_context: Context,
+    ):
         raise NotImplementedError
 
     def store_decimal(
-            self,
-            dummy_address,
-            dummy_length,
-            dummy_value,
-            dummy_context):
-
+        self,
+        dummy_address: Address,
+        dummy_length: int,
+        dummy_value: int,
+        dummy_context: Context,
+    ):
         raise NotImplementedError
 
     @property
     def program_counter(self):
         raise NotImplementedError
 
-    def branch_unconditional_relative(self, source, target):
-
+    def branch_unconditional_relative(
+        self,
+        source: InstructionAddress | Address,
+        target: InstructionAddress | Address,
+    ):
         LOG.debug("Source: %s", source)
         LOG.debug("Target: %s", target)
 
         if isinstance(target, InstructionAddress):
             target_address = target
         elif isinstance(target, Instruction):
             target_address = target.address
@@ -528,26 +467,26 @@
             raise NotImplementedError
 
         if target.base_address != source.base_address:
             # Assume symbolic generation
             instruction = self.new_instruction("JAL_V0")
             source_address = source
             instruction.set_address(source_address)
-            instruction.operands()[1].set_value(self.target.registers['X0'])
+            instruction.operands()[1].set_value(self.target.registers["X0"])
             instruction.memory_operands()[0].set_address(target_address, None)
             return instruction
 
         elif isinstance(source, InstructionAddress):
             source_address = source
 
             relative_offset = target_address - source_address
 
             instruction = self.new_instruction("JAL_V0")
             instruction.set_address(source_address)
-            instruction.operands()[1].set_value(self.target.registers['X0'])
+            instruction.operands()[1].set_value(self.target.registers["X0"])
 
             LOG.debug("Source address: %s", source_address)
             LOG.debug("Target address: %s", target_address)
             LOG.debug("Relative offset: %s", relative_offset)
 
         elif isinstance(source, Instruction):
             source_address = source.address
@@ -561,20 +500,104 @@
             if not operand.type.address_relative:
                 continue
 
             operand.set_value(relative_offset)
 
         return instruction
 
-    def add_to_register(self, register, value):
+    def branch_unconditional_relative2(self, source, target):
+        LOG.debug("Source: %s", source)
+        LOG.debug("Target: %s", target)
+
+        if isinstance(target, InstructionAddress):
+            target_address = target
+        elif isinstance(target, Instruction):
+            target_address = target.address
+        else:
+            print(("Target:", target))
+            raise NotImplementedError
+
+        if target.base_address != source.base_address:
+            # Assume symbolic generation
+            instruction = self.new_instruction("JAL_V0")
+            source_address = source
+            instruction.set_address(source_address)
+            instruction.operands()[1].set_value(self.target.registers["X0"])
+            instruction.memory_operands()[0].set_address(target_address, None)
+            return [instruction]
+
+        elif isinstance(source, InstructionAddress):
+            source_address = source
+
+            relative_offset = target_address - source_address
 
-        instrs = []
-        if register.type.name == "ireg" and isinstance(value,
-                                                       six.integer_types):
+            instruction = self.new_instruction("JAL_V0")
+            instruction.set_address(source_address)
+            instruction.operands()[1].set_value(self.target.registers["X0"])
+
+            LOG.debug("Source address: %s", source_address)
+            LOG.debug("Target address: %s", target_address)
+            LOG.debug("Relative offset: %s", relative_offset)
 
+        elif isinstance(source, Instruction):
+            source_address = source.address
+            relative_offset = target_address - source_address
+            instruction = source
+        else:
+            print(("Source:", source))
+            raise NotImplementedError
+
+        if relative_offset < -524288 or relative_offset > 524287:
+            instructions = []
+
+            relative_offset_high = (relative_offset >> 12) & 0xFFFFF
+            relative_offset_low = relative_offset & 0xFFF
+
+            # Because immediate values are sign-extended, we need to
+            # pre-increment the upper immediate bits to counteract the case
+            # in which the lower immediate forms a negative number (MSB is 1)
+            if relative_offset_low & (1 << 11):
+                relative_offset_high = (relative_offset_high + 1) & 0xFFFFF
+
+                # While we're at it, convert the lower immediate to negative
+                # using 2's complement
+                relative_offset_low = relative_offset_low - 2**12
+
+            ins = self.new_instruction("AUIPC_V0")
+            ins.set_operands(
+                [relative_offset_high, self.target.registers["X1"]]
+            )
+            instructions.append(ins)
+
+            ins = self.new_instruction("JALR_V0")
+            ins.set_operands(
+                [
+                    relative_offset_low,
+                    self.target.registers["X1"],
+                    self.target.registers["X0"],
+                ]
+            )
+            instructions.append(ins)
+
+            return instructions
+
+        else:
+            for operand in instruction.operands():
+                if not operand.type.address_relative:
+                    continue
+
+                operand.set_value(relative_offset)
+
+            return [instruction]
+
+    def add_to_register(self, register: Register, value: int):
+        instrs: List[Instruction] = []
+        if register.type.name == "ireg" and isinstance(
+            value, six.integer_types
+        ):
             if value > 0:
                 while (value) > 0x7FF:
                     addi = self.new_instruction("ADDI_V0")
                     addi.set_operands([0x7FF, register, register])
                     instrs.append(addi)
                     value = value - 0x7FF
             elif value < 0:
@@ -589,18 +612,24 @@
                 addi.set_operands([value, register, register])
                 instrs.append(addi)
         else:
             raise NotImplementedError
 
         return instrs
 
-    def compare_and_branch(self, val1, val2, cond, target, context):
-
+    def compare_and_branch(
+        self,
+        val1: Register,
+        val2: Register,
+        cond: str,
+        target: Target | str,
+        context: Context,
+    ):
         assert cond in ["<", ">", "!=", "=", ">=", "<="]
-        instrs = []
+        instrs: List[Instruction] = []
 
         # put all values into registers
         if isinstance(val1, int) and isinstance(val1, six.integer_types):
             raise NotImplementedError
         elif isinstance(val1, six.integer_types):
             instrs += self.set_register(
                 self.scratch_registers[0], val1, context
@@ -635,21 +664,22 @@
 
         bc_ins.set_operands([target, val2, val1, 0])
         instrs.append(bc_ins)
         return instrs
 
     def nop(self):
         instr = self.new_instruction("ADDI_V0")
-        instr.set_operands([0,
-                            self.target.registers['X0'],
-                            self.target.registers['X0']])
+        instr.set_operands(
+            [0, self.target.registers["X0"], self.target.registers["X0"]]
+        )
         return instr
 
-    def negate_register(self, dummy_register, dummy_context):
-
+    def negate_register(
+        self, dummy_register: Register, dummy_context: Context
+    ):
         raise NotImplementedError
 
     @property
     def context_var(self):
         if self._context_var is None:
             self._context_var = VariableArray(
                 "%s_CONTEXT_VAR" % self._name.upper(), "uint8_t", 600
@@ -657,61 +687,56 @@
         return self._context_var
 
     def set_context(self, variable=None, tmpl_path=None):
         """ """
         if tmpl_path is None:
             tmpl_path = _MODULE_DIR
 
-        return super(
-            RISCVISA,
-            self).set_context(
-            variable=variable,
-            tmpl_path=tmpl_path)
+        return super(RISCVISA, self).set_context(
+            variable=variable, tmpl_path=tmpl_path
+        )
 
     def get_context(self, variable=None, tmpl_path=None):
         """ """
 
         if tmpl_path is None:
             tmpl_path = _MODULE_DIR
 
-        return super(
-            RISCVISA,
-            self).get_context(
-            variable=variable,
-            tmpl_path=tmpl_path)
+        return super(RISCVISA, self).get_context(
+            variable=variable, tmpl_path=tmpl_path
+        )
 
-    def normalize_asm(self, mnemonic, operands):
+    def normalize_asm(self, mnemonic: str, operands: List[str]):
         """ """
 
         if mnemonic == "FENCE":
-            new_operands = []
+            new_operands: List[str] = []
             for operand in operands:
                 value = 0
-                if 'I' in operand:
+                if "I" in operand:
                     value += 8
-                if 'O' in operand:
+                if "O" in operand:
                     value += 4
-                if 'R' in operand:
+                if "R" in operand:
                     value += 2
-                if 'W' in operand:
+                if "W" in operand:
                     value += 1
                 new_operands.append(str(value))
             return mnemonic, new_operands
         elif mnemonic == "C.JR" or mnemonic == "C.JALR":
-            operands.append('X0')
+            operands.append("X0")
             return mnemonic, operands
         else:
             # Remove the implicit stack pointer operand from all instructions
             new_operands = [op for op in operands if op != "SP"]
 
             return mnemonic, new_operands
 
-    def randomize_register(self, register, seed=None):
-
-        instrs = []
+    def randomize_register(self, register: Register, seed: int | None = None):
+        instrs: List[Instruction] = []
 
         ins = self.new_instruction("MUL_V0")
         ins.set_operands([register, register, register])
         instrs.append(ins)
 
         if seed is not None:
             ins = self.new_instruction("ADD_V0")
@@ -728,34 +753,35 @@
 
         ins = self.new_instruction("OR_V0")
         ins.set_operands([self._scratch_registers[0], register, register])
         instrs.append(ins)
 
         return instrs
 
-    def get_register_for_address_arithmetic(self, context):
+    def get_register_for_address_arithmetic(self, context: Context):
         """
 
         :param context:
 
         """
         reg = [
             reg
             for reg in self._address_registers
             if reg not in context.reserved_registers
-            and int(reg.codification) >= 8 and int(reg.codification) <= 15
+            and int(reg.codification) >= 8
+            and int(reg.codification) <= 15
         ]
 
         reg += [
             reg
             for reg in self._address_registers
             if reg not in context.reserved_registers
-            and int(reg.codification) < 8 and int(reg.codification) > 15
+            and int(reg.codification) < 8
+            and int(reg.codification) > 15
         ]
 
         if len(reg) == 0:
             raise MicroprobeCodeGenerationError(
-                "No free registers available. "
-                "Change your policy."
+                "No free registers available. " "Change your policy."
             )
 
         return reg[0]
```

## microprobe/definitions/riscv/isa/riscv-common/operand.yaml

```diff
@@ -257,14 +257,18 @@
     X31 : ['X31']
   AddressBase: True
 - Name: s.imm12
   Description: signed 12-bit immediate
   Min: -2048
   Max: 2047
   AddressIndex: True 
+- Name: u.imm12
+  Description: unsigned 12-bit immediate
+  Min: 0
+  Max: 4096
 - Name: s.imm20
   Description: signed 20-bit immediate
   Min: -524288
   Max: 524287
 - Name: s.imm6
   Description: signed 6-bit immediate
   Min: -32
```

## microprobe/definitions/riscv/templates/riscv.ldscript

```diff
@@ -7,15 +7,15 @@
 	      "elf64-littleriscv")
 OUTPUT_ARCH(riscv)
 ENTRY(_start)
 SEARCH_DIR("=/usr/local/lib/riscv64-linux-gnu"); SEARCH_DIR("=/lib/riscv64-linux-gnu"); SEARCH_DIR("=/usr/lib/riscv64-linux-gnu"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/riscv64-linux-gnu/lib64"); SEARCH_DIR("=/usr/riscv64-linux-gnu/lib");
 SECTIONS
 {
   /* Read-only sections, merged into text segment: */
-  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x1000)); . = SEGMENT_START("text-segment", 0x1000) + SIZEOF_HEADERS;
+  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x10000)); . = SEGMENT_START("text-segment", 0x10000) + SIZEOF_HEADERS;
   .interp         : { *(.interp) }
   .note.gnu.build-id : { *(.note.gnu.build-id) }
   .hash           : { *(.hash) }
   .gnu.hash       : { *(.gnu.hash) }
   .dynsym         : { *(.dynsym) }
   .dynstr         : { *(.dynstr) }
   .gnu.version    : { *(.gnu.version) }
```

## microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_linux_gcc.ldscript

```diff
@@ -7,15 +7,15 @@
 	      "elf64-littleriscv")
 OUTPUT_ARCH(riscv)
 ENTRY(_start)
 SEARCH_DIR("=/usr/local/lib/riscv64-linux-gnu"); SEARCH_DIR("=/lib/riscv64-linux-gnu"); SEARCH_DIR("=/usr/lib/riscv64-linux-gnu"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/riscv64-linux-gnu/lib64"); SEARCH_DIR("=/usr/riscv64-linux-gnu/lib");
 SECTIONS
 {
   /* Read-only sections, merged into text segment: */
-  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x1000)); . = SEGMENT_START("text-segment", 0x1000) + SIZEOF_HEADERS;
+  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x10000)); . = SEGMENT_START("text-segment", 0x10000) + SIZEOF_HEADERS;
   .interp         : { *(.interp) }
   .note.gnu.build-id : { *(.note.gnu.build-id) }
   .hash           : { *(.hash) }
   .gnu.hash       : { *(.gnu.hash) }
   .dynsym         : { *(.dynsym) }
   .dynstr         : { *(.dynstr) }
   .gnu.version    : { *(.gnu.version) }
```

## Comparing `microprobe_target_riscv-0.5.20220906104555.dist-info/LICENSE` & `microprobe_target_riscv-0.5.20230629114852.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `microprobe_target_riscv-0.5.20220906104555.dist-info/METADATA` & `microprobe_target_riscv-0.5.20230629114852.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: microprobe-target-riscv
-Version: 0.5.20220906104555
+Version: 0.5.20230629114852
 Summary: Microprobe: Microbenchmark generation framework: Target definitions for RISCV
 Home-page: https://github.com/IBM/microprobe
 Author: Ramon Bertran
 Author-email: rbertra@us.ibm.com
 Maintainer: Ramon Bertran
 Maintainer-email: rbertra@us.ibm.com
 License: Apache Version 2.0
```

## Comparing `microprobe_target_riscv-0.5.20220906104555.dist-info/RECORD` & `microprobe_target_riscv-0.5.20230629114852.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,17 @@
 microprobe/definitions/riscv/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/doc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/doc/examples.rst,sha256=2Dw3JeGrTR19vaHPQM-c89YUMtwTbdh4i4seevoU2H8,18
 microprobe/definitions/riscv/doc/examples_riscv.rst,sha256=dG8XPZhrg1BAxNHKdMBZiF21TrAMitBA3Un8Kr1xk_U,173
 microprobe/definitions/riscv/env/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+microprobe/definitions/riscv/env/riscv_eprocessor_sim.py,sha256=0ZNSiWCpQ1r_vSTdIn_ddBrw4x9d9YdkVNEsVK0U71g,14456
 microprobe/definitions/riscv/env/riscv_linux_gcc.py,sha256=HFH_Kf4r3WxYQjWR8GcKBfJICuQ2-6VoKfJWUFqrYpc,3660
+microprobe/definitions/riscv/env/riscv_riscy_sim.py,sha256=gVkLB6dspSQe2HnjZ6LvlHEiZorAKdGQcb7wnEXsJKE,10005
+microprobe/definitions/riscv/env/riscv_sargantana_sim.py,sha256=dQwvdjQpGroJeRySCjLGDmGuNvq0elPx5bjaFi3zYps,9977
+microprobe/definitions/riscv/env/riscv_spike_sim.py,sha256=HlAoSSk0rZNbC3uaL_guNXvtBnVzqYY6FxjdwIlrRFw,8530
 microprobe/definitions/riscv/env/riscv_test_p.py,sha256=nWpvsxOJCR8ocKim3J5GhocLFgjhpHcQDdjwk3AOD8I,3115
 microprobe/definitions/riscv/examples/Makefile.in,sha256=vuLJXsRx_4FKeKWH6lnEQoEAAxwFaB4pA5_Q9vXDo98,505
 microprobe/definitions/riscv/examples/Makefrag,sha256=7h_StI9OvTD4TPI0x-5MIwRhVKMX7l_5vCoR_jfWPaw,160
 microprobe/definitions/riscv/examples/README.md,sha256=K4VaRsRBU4Z-O5Zw37SyRUYksySfc07bjK8zSl0y3xw,6417
 microprobe/definitions/riscv/examples/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/examples/configure.ac,sha256=smrWeSF3Dno9QWZ5mN7lzHBiRQwy62yurCk7U4n9oZQ,594
 microprobe/definitions/riscv/examples/riscv_branch.py,sha256=Ycm_IzY-eltSkN_YUdO4uD_oY1bjTdfL1j1ldFhXFeA,12209
@@ -18,23 +22,23 @@
 microprobe/definitions/riscv/examples/riscv_ipc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/isa/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/isa/riscv-common/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/isa/riscv-common/comparator.py,sha256=rN2HdBFgUxnYHA_nnAcrLTGyESCTOywpYR7HzM4jZHo,635
 microprobe/definitions/riscv/isa/riscv-common/generator.py,sha256=rN2HdBFgUxnYHA_nnAcrLTGyESCTOywpYR7HzM4jZHo,635
 microprobe/definitions/riscv/isa/riscv-common/getcontext.S,sha256=Lb_k02VhqZrUBWIluZpaDfH4Om29b2DZc9ck7V4Lsmk,1130
 microprobe/definitions/riscv/isa/riscv-common/instruction.py,sha256=dWTopVCeip5H3FrcsJ6kIv0BirBGZIvKPyEzqOlwhFY,14006
-microprobe/definitions/riscv/isa/riscv-common/instruction.yaml,sha256=2DAxsBJzh1sVA-V6SqeIEaRukVKJJ4vaCpOFCC3Jqug,68224
+microprobe/definitions/riscv/isa/riscv-common/instruction.yaml,sha256=g1iNwdBd-7DQrFB1eKLd5tt1CXAo2YGgOwf1yFg4Nr0,68454
 microprobe/definitions/riscv/isa/riscv-common/instruction_field.py,sha256=ZT9Kk8iSEKCghH9vR6MAvLWY3EHeKfeW0QG-huAkjDE,891
-microprobe/definitions/riscv/isa/riscv-common/instruction_field.yaml,sha256=prVyQLRe5oa5Yb_rIFavuVR6yP3Omu8k3pFELp4sda0,8059
+microprobe/definitions/riscv/isa/riscv-common/instruction_field.yaml,sha256=weCwyR89KPjwIddTYkrvE8lubWxR1jDcCDAUpS3VAnY,8157
 microprobe/definitions/riscv/isa/riscv-common/instruction_format.py,sha256=xmfHF44j7kYvemaICgbDiJBj2UgR49eZblihYNDleqE,896
-microprobe/definitions/riscv/isa/riscv-common/instruction_format.yaml,sha256=bEl_rYzg2UzqL_Nnufu2djcQGPZ7MMwq11DLvqqKsj8,8377
-microprobe/definitions/riscv/isa/riscv-common/isa.py,sha256=q-7PI3u2sGHcnrep3ffDJYTojFhZ1D6CEiDqUV3YTCg,27197
+microprobe/definitions/riscv/isa/riscv-common/instruction_format.yaml,sha256=bDloAPLCE1yc0inEMaQYDZJo5UazNBhtQO9Rsr0z_sA,8483
+microprobe/definitions/riscv/isa/riscv-common/isa.py,sha256=A8Y8esrGodB-CEjiWO_C_hqATYiy93MZ5zjGjw1MhDY,26701
 microprobe/definitions/riscv/isa/riscv-common/isa.yaml,sha256=_zwwl4E2wljd8N8lE1vTOujWLF65ljli9hxBwWZ4X1s,1288
 microprobe/definitions/riscv/isa/riscv-common/operand.py,sha256=rN2HdBFgUxnYHA_nnAcrLTGyESCTOywpYR7HzM4jZHo,635
-microprobe/definitions/riscv/isa/riscv-common/operand.yaml,sha256=fuI9r-QlA4N6-YYd8lbRwPKlGkxhGlkbcLUodbr1yOA,9936
+microprobe/definitions/riscv/isa/riscv-common/operand.yaml,sha256=okQNdSKORNhBrmezPnf8_CvikJjkHDpS5n_FL1-Y0TA,10014
 microprobe/definitions/riscv/isa/riscv-common/register.py,sha256=0qaqGNu5i5AAbuBLvr7SD2dpWWTS9e3JqklVD3io8iA,862
 microprobe/definitions/riscv/isa/riscv-common/register.yaml,sha256=6qnSHTEOcdFsAjgv5_K44XQEhnZB2wibnSr5vXJBz0w,950
 microprobe/definitions/riscv/isa/riscv-common/register_type.py,sha256=q--e6v7zg1K3fyeXMOTHUW8B1TkwuDDW31hUejwG9yI,884
 microprobe/definitions/riscv/isa/riscv-common/register_type.yaml,sha256=RGjNiRGJKAX2lsJfVfOdm2YBRMrk3rb2aE4Bspx5gKM,846
 microprobe/definitions/riscv/isa/riscv-common/setcontext.S,sha256=0n-twbjAdOR5qT6S114kI2Mx93xCYU-oztZmA81Np4w,1130
 microprobe/definitions/riscv/isa/riscv-common/instruction_props/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/isa/riscv-common/instruction_props/branch.yaml,sha256=_GNq_zFjxNjASMULMPTKi54wJNiurhPpy7O4dSPoEtw,944
@@ -51,16 +55,21 @@
 microprobe/definitions/riscv/isa/riscv-v2_2/instruction.yaml,sha256=npVcCijMVK-SpRQINhfZp877oWzSjQ_DrdvHWU0mkkk,581
 microprobe/definitions/riscv/isa/riscv-v2_2/isa.yaml,sha256=t6ud9tTcuS1ZGpDvRNNBuqLRQ2GxKyYPDQz2VHuKyDI,686
 microprobe/definitions/riscv/policies/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/policies/epi.py,sha256=b_z_J_lmgGJwrUy3KptNZh0ziQbQOyZlZEjhsPleIok,5081
 microprobe/definitions/riscv/policies/seq.py,sha256=tTeydjxT48xYUMXDse7wxKcCyNxtJ1DAi-FLc6TXpaQ,5798
 microprobe/definitions/riscv/policies/seqtune.py,sha256=36gbNi02s0tb8yM_jtl0SUGz4CZBYBls1iiBBRCZW-E,7078
 microprobe/definitions/riscv/templates/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-microprobe/definitions/riscv/templates/riscv.ldscript,sha256=mOCwA4aGqbwDOyS_ihNEgSDFG31Vfc39HQFc_B9r6cg,9157
-microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_linux_gcc.ldscript,sha256=mOCwA4aGqbwDOyS_ihNEgSDFG31Vfc39HQFc_B9r6cg,9157
+microprobe/definitions/riscv/templates/riscv.ldscript,sha256=L9LkjOT9Nmhme7kBkzUlKzDd1nDDpViwXXmwMuGLIr4,9159
+microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_eprocessor_sim.ldscript,sha256=qhI39IgSWrcOQjxeFkdin7FltkvgZBMe2XaWDdHXH6s,13
+microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_linux_gcc.ldscript,sha256=L9LkjOT9Nmhme7kBkzUlKzDd1nDDpViwXXmwMuGLIr4,9159
+microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_riscy_sim.ldscript,sha256=qhI39IgSWrcOQjxeFkdin7FltkvgZBMe2XaWDdHXH6s,13
+microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_sargantana_sim.ldscript,sha256=qhI39IgSWrcOQjxeFkdin7FltkvgZBMe2XaWDdHXH6s,13
+microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_spike_sim.ldscript,sha256=dX6hax-P8-ubrD4e8hDMTOf2yAMW-Mogkr8cG2Ul_ks,111
+microprobe/definitions/riscv/templates/riscv_v22-riscv_generic-riscv64_spike_sim_routines.s,sha256=yxaVLQNBsxpgbPgTUTYklAnZ4FcD6coGKGve7-04jNQ,202
 microprobe/definitions/riscv/uarch/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/uarch/riscv-common/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/uarch/riscv-common/element.py,sha256=iz5hBdaZdlA3Zq3H_CXttQOkMge_indAP8q8mpE3o_s,857
 microprobe/definitions/riscv/uarch/riscv-common/element.yaml,sha256=8_26tI4-agERKXvmS1p9TBMF0B5MItdCB1HepX8gcvg,666
 microprobe/definitions/riscv/uarch/riscv-common/element_type.py,sha256=aADm-6XJTBfaXVQ_E6yjFQFT6BZo8QCCqfS35G_y9wY,880
 microprobe/definitions/riscv/uarch/riscv-common/element_type.yaml,sha256=lM3oZKial0MqJKjkmO1-xvUfF_HQp1iq78WjsSN09Vk,968
 microprobe/definitions/riscv/uarch/riscv-common/microarchitecture.py,sha256=ASwiPYDyPveZhMMHOZjwS7GKDfWPAlpzmksInTfwJpo,834
@@ -70,12 +79,12 @@
 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/cache_level.yaml,sha256=AYgTIXISRbkdHqSePxSlH1CvFIBbIMwYtZAQrK4LSHw,730
 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/data_cache.yaml,sha256=s3Ut8xcJw-zMnwMj_QwLdxC1-IlbfCnO8q2FnnL_Yzw,718
 microprobe/definitions/riscv/uarch/riscv-common/element_type_props/instruction_cache.yaml,sha256=6lnk2vpMqXbh1S7qgzG1WBJrw8xeNDSf5bgEWpPF-EI,732
 microprobe/definitions/riscv/uarch/riscv-generic/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/uarch/riscv-generic/microarchitecture.yaml,sha256=XgB96x7t9alMAh2KtBjfkE7prCQpZH3NPxVmRdOG8hg,671
 microprobe/definitions/riscv/wrappers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 microprobe/definitions/riscv/wrappers/riscv-tests.py,sha256=Yl7uzIvjxJZqYi4qcnSjbRvrw5EFeSp5zGGclM3Omss,3035
-microprobe_target_riscv-0.5.20220906104555.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
-microprobe_target_riscv-0.5.20220906104555.dist-info/METADATA,sha256=DecpNz6qVSxa7S-aSasYlFItofwKHYPlJPJkj86lqk4,1718
-microprobe_target_riscv-0.5.20220906104555.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
-microprobe_target_riscv-0.5.20220906104555.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
-microprobe_target_riscv-0.5.20220906104555.dist-info/RECORD,,
+microprobe_target_riscv-0.5.20230629114852.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
+microprobe_target_riscv-0.5.20230629114852.dist-info/METADATA,sha256=reElpjul9h0I6yLslFglPgdN-91lEs2UovsUwD_R5Uc,1718
+microprobe_target_riscv-0.5.20230629114852.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+microprobe_target_riscv-0.5.20230629114852.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
+microprobe_target_riscv-0.5.20230629114852.dist-info/RECORD,,
```

